// src/render-media-on-web.tsx
import {
  AudioSampleSource,
  BufferTarget,
  Output,
  StreamTarget,
  VideoSampleSource
} from "mediabunny";
import { Internals as Internals7 } from "remotion";

// src/add-sample.ts
import { AudioSample, VideoSample } from "mediabunny";
var addVideoSampleAndCloseFrame = async (frameToEncode, videoSampleSource) => {
  const sample = new VideoSample(frameToEncode);
  try {
    await videoSampleSource.add(sample);
  } finally {
    sample.close();
    frameToEncode.close();
  }
};
var addAudioSample = async (audio, audioSampleSource) => {
  const sample = new AudioSample(audio);
  try {
    await audioSampleSource.add(sample);
  } finally {
    sample.close();
  }
};

// src/artifact.ts
import { NoReactInternals } from "remotion/no-react";
var onlyArtifact = async ({
  assets,
  frameBuffer
}) => {
  const artifacts = assets.filter((asset) => asset.type === "artifact");
  let frameBufferUint8 = null;
  const result = [];
  for (const artifact of artifacts) {
    if (artifact.contentType === "binary" || artifact.contentType === "text") {
      result.push({
        frame: artifact.frame,
        content: artifact.content,
        filename: artifact.filename,
        downloadBehavior: artifact.downloadBehavior
      });
      continue;
    }
    if (artifact.contentType === "thumbnail") {
      if (frameBuffer === null) {
        continue;
      }
      const ab = frameBuffer instanceof Blob ? await frameBuffer.arrayBuffer() : new Uint8Array(await (await frameBuffer.convertToBlob({ type: "image/png" })).arrayBuffer());
      frameBufferUint8 = new Uint8Array(ab);
      result.push({
        frame: artifact.frame,
        content: frameBufferUint8,
        filename: artifact.filename,
        downloadBehavior: artifact.downloadBehavior
      });
      continue;
    }
    throw new Error("Unknown artifact type: " + artifact);
  }
  return result.filter(NoReactInternals.truthy);
};
var handleArtifacts = () => {
  const previousArtifacts = [];
  const handle = async ({
    imageData,
    frame,
    assets: artifactAssets,
    onArtifact
  }) => {
    const artifacts = await onlyArtifact({
      assets: artifactAssets,
      frameBuffer: imageData
    });
    for (const artifact of artifacts) {
      const previousArtifact = previousArtifacts.find((a) => a.filename === artifact.filename);
      if (previousArtifact) {
        throw new Error(`An artifact with output "${artifact.filename}" was already registered at frame ${previousArtifact.frame}, but now registered again at frame ${frame}. Artifacts must have unique names. https://remotion.dev/docs/artifacts`);
      }
      onArtifact(artifact);
      previousArtifacts.push({ frame, filename: artifact.filename });
    }
  };
  return { handle };
};

// src/audio.ts
var TARGET_NUMBER_OF_CHANNELS = 2;
var TARGET_SAMPLE_RATE = 48000;
function mixAudio(waves, length) {
  if (waves.length === 1 && waves[0].length === length) {
    return waves[0];
  }
  const mixed = new Int16Array(length);
  if (waves.length === 1) {
    mixed.set(waves[0].subarray(0, length));
    return mixed;
  }
  for (let i = 0;i < length; i++) {
    const sum = waves.reduce((acc, wave) => {
      return acc + (wave[i] ?? 0);
    }, 0);
    mixed[i] = Math.max(-32768, Math.min(32767, sum));
  }
  return mixed;
}
var onlyInlineAudio = ({
  assets,
  fps,
  frame
}) => {
  const inlineAudio = assets.filter((asset) => asset.type === "inline-audio");
  if (inlineAudio.length === 0) {
    return null;
  }
  const expectedLength = Math.round(TARGET_NUMBER_OF_CHANNELS * TARGET_SAMPLE_RATE / fps);
  for (const asset of inlineAudio) {
    if (asset.toneFrequency !== 1) {
      throw new Error("Setting the toneFrequency is not supported yet in web rendering.");
    }
  }
  const mixedAudio = mixAudio(inlineAudio.map((asset) => asset.audio), expectedLength);
  return new AudioData({
    data: mixedAudio,
    format: "s16",
    numberOfChannels: TARGET_NUMBER_OF_CHANNELS,
    numberOfFrames: expectedLength / TARGET_NUMBER_OF_CHANNELS,
    sampleRate: TARGET_SAMPLE_RATE,
    timestamp: frame / fps * 1e6
  });
};

// src/can-use-webfs-target.ts
var canUseWebFsWriter = async () => {
  if (!("storage" in navigator)) {
    return false;
  }
  if (!("getDirectory" in navigator.storage)) {
    return false;
  }
  try {
    const directoryHandle = await navigator.storage.getDirectory();
    const fileHandle = await directoryHandle.getFileHandle("remotion-probe-web-fs-support", {
      create: true
    });
    const canUse = fileHandle.createWritable !== undefined;
    return canUse;
  } catch {
    return false;
  }
};

// src/create-scaffold.tsx
import { createRef } from "react";
import { flushSync as flushSync2 } from "react-dom";
import ReactDOM from "react-dom/client";
import { Internals as Internals2 } from "remotion";

// src/update-time.tsx
import { useImperativeHandle, useState } from "react";
import { flushSync } from "react-dom";
import { Internals } from "remotion";
import { jsx } from "react/jsx-runtime";
var UpdateTime = ({
  children,
  audioEnabled,
  videoEnabled,
  logLevel,
  compId,
  initialFrame,
  timeUpdater
}) => {
  const [frame, setFrame] = useState(initialFrame);
  useImperativeHandle(timeUpdater, () => ({
    update: (f) => {
      flushSync(() => {
        setFrame(f);
      });
    }
  }));
  return /* @__PURE__ */ jsx(Internals.RemotionRootContexts, {
    audioEnabled,
    videoEnabled,
    logLevel,
    numberOfAudioTags: 0,
    audioLatencyHint: "interactive",
    frameState: {
      [compId]: frame
    },
    children
  });
};

// src/with-resolvers.ts
var withResolvers = function() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
};

// src/create-scaffold.tsx
import { jsx as jsx2 } from "react/jsx-runtime";
async function createScaffold({
  width,
  height,
  delayRenderTimeoutInMilliseconds,
  logLevel,
  resolvedProps,
  id,
  mediaCacheSizeInBytes,
  durationInFrames,
  fps,
  initialFrame,
  schema,
  Component,
  audioEnabled,
  videoEnabled,
  defaultCodec,
  defaultOutName
}) {
  if (!ReactDOM.createRoot) {
    throw new Error("@remotion/web-renderer requires React 18 or higher");
  }
  const div = document.createElement("div");
  div.style.position = "fixed";
  div.style.display = "flex";
  div.style.flexDirection = "column";
  div.style.backgroundColor = "transparent";
  div.style.width = `${width}px`;
  div.style.height = `${height}px`;
  div.style.zIndex = "-9999";
  div.style.top = "0";
  div.style.left = "0";
  div.style.right = "0";
  div.style.bottom = "0";
  div.style.visibility = "hidden";
  div.style.pointerEvents = "none";
  const scaffoldClassName = `remotion-scaffold-${Math.random().toString(36).substring(2, 15)}`;
  div.className = scaffoldClassName;
  const cleanupCSS = Internals2.CSSUtils.injectCSS(Internals2.CSSUtils.makeDefaultPreviewCSS(`.${scaffoldClassName}`, "white"));
  document.body.appendChild(div);
  const { promise, resolve, reject } = withResolvers();
  const root = ReactDOM.createRoot(div, {
    onUncaughtError: (err) => {
      reject(err);
    }
  });
  const delayRenderScope = {
    remotion_renderReady: true,
    remotion_delayRenderTimeouts: {},
    remotion_puppeteerTimeout: delayRenderTimeoutInMilliseconds,
    remotion_attempt: 0,
    remotion_delayRenderHandles: []
  };
  const timeUpdater = createRef();
  const collectAssets = createRef();
  flushSync2(() => {
    root.render(/* @__PURE__ */ jsx2(Internals2.MaxMediaCacheSizeContext.Provider, {
      value: mediaCacheSizeInBytes,
      children: /* @__PURE__ */ jsx2(Internals2.RemotionEnvironmentContext.Provider, {
        value: {
          isStudio: false,
          isRendering: true,
          isPlayer: false,
          isReadOnlyStudio: false,
          isClientSideRendering: true
        },
        children: /* @__PURE__ */ jsx2(Internals2.DelayRenderContextType.Provider, {
          value: delayRenderScope,
          children: /* @__PURE__ */ jsx2(Internals2.CompositionManager.Provider, {
            value: {
              compositions: [
                {
                  id,
                  component: Component,
                  nonce: 0,
                  defaultProps: {},
                  folderName: null,
                  parentFolderName: null,
                  schema: schema ?? null,
                  calculateMetadata: null,
                  durationInFrames,
                  fps,
                  height,
                  width
                }
              ],
              canvasContent: {
                type: "composition",
                compositionId: id
              },
              currentCompositionMetadata: {
                props: resolvedProps,
                durationInFrames,
                fps,
                height,
                width,
                defaultCodec: defaultCodec ?? null,
                defaultOutName: defaultOutName ?? null,
                defaultVideoImageFormat: null,
                defaultPixelFormat: null,
                defaultProResProfile: null
              },
              folders: []
            },
            children: /* @__PURE__ */ jsx2(Internals2.RenderAssetManagerProvider, {
              collectAssets,
              children: /* @__PURE__ */ jsx2(UpdateTime, {
                audioEnabled,
                videoEnabled,
                logLevel,
                compId: id,
                initialFrame,
                timeUpdater,
                children: /* @__PURE__ */ jsx2(Internals2.CanUseRemotionHooks.Provider, {
                  value: true,
                  children: /* @__PURE__ */ jsx2(Component, {
                    ...resolvedProps
                  })
                })
              })
            })
          })
        })
      })
    }));
  });
  resolve();
  await promise;
  return {
    delayRenderScope,
    div,
    cleanupScaffold: () => {
      root.unmount();
      div.remove();
      cleanupCSS();
    },
    timeUpdater,
    collectAssets
  };
}

// src/frame-range.ts
var getRealFrameRange = (durationInFrames, frameRange) => {
  if (frameRange === null) {
    return [0, durationInFrames - 1];
  }
  if (typeof frameRange === "number") {
    if (frameRange < 0 || frameRange >= durationInFrames) {
      throw new Error(`Frame number is out of range, must be between 0 and ${durationInFrames - 1} but got ${frameRange}`);
    }
    return [frameRange, frameRange];
  }
  if (frameRange[1] >= durationInFrames || frameRange[0] < 0) {
    throw new Error(`The "durationInFrames" of the composition was evaluated to be ${durationInFrames}, but frame range ${frameRange.join("-")} is not inbetween 0-${durationInFrames - 1}`);
  }
  return frameRange;
};

// src/get-audio-encoding-config.ts
import {
  canEncodeAudio,
  QUALITY_MEDIUM
} from "mediabunny";
var getDefaultAudioEncodingConfig = async () => {
  const preferredDefaultAudioEncodingConfig = {
    codec: "aac",
    bitrate: QUALITY_MEDIUM
  };
  if (await canEncodeAudio(preferredDefaultAudioEncodingConfig.codec, preferredDefaultAudioEncodingConfig)) {
    return preferredDefaultAudioEncodingConfig;
  }
  const backupDefaultAudioEncodingConfig = {
    codec: "opus",
    bitrate: QUALITY_MEDIUM
  };
  if (await canEncodeAudio(backupDefaultAudioEncodingConfig.codec, backupDefaultAudioEncodingConfig)) {
    return backupDefaultAudioEncodingConfig;
  }
  return null;
};

// src/internal-state.ts
var makeInternalState = () => {
  let drawnPrecomposedPixels = 0;
  let precomposedTextures = 0;
  return {
    getDrawn3dPixels: () => drawnPrecomposedPixels,
    getPrecomposedTiles: () => precomposedTextures,
    addPrecompose: ({
      canvasWidth,
      canvasHeight
    }) => {
      drawnPrecomposedPixels += canvasWidth * canvasHeight;
      precomposedTextures++;
    }
  };
};

// src/mediabunny-mappings.ts
import {
  Mp4OutputFormat,
  QUALITY_HIGH,
  QUALITY_LOW,
  QUALITY_MEDIUM as QUALITY_MEDIUM2,
  QUALITY_VERY_HIGH,
  QUALITY_VERY_LOW,
  WebMOutputFormat
} from "mediabunny";
var codecToMediabunnyCodec = (codec) => {
  switch (codec) {
    case "h264":
      return "avc";
    case "h265":
      return "hevc";
    case "vp8":
      return "vp8";
    case "vp9":
      return "vp9";
    case "av1":
      return "av1";
    default:
      throw new Error(`Unsupported codec: ${codec}`);
  }
};
var containerToMediabunnyContainer = (container) => {
  switch (container) {
    case "mp4":
      return new Mp4OutputFormat;
    case "webm":
      return new WebMOutputFormat;
    default:
      throw new Error(`Unsupported container: ${container}`);
  }
};
var getDefaultVideoCodecForContainer = (container) => {
  switch (container) {
    case "mp4":
      return "h264";
    case "webm":
      return "vp8";
    default:
      throw new Error(`Unsupported container: ${container}`);
  }
};
var getQualityForWebRendererQuality = (quality) => {
  switch (quality) {
    case "very-low":
      return QUALITY_VERY_LOW;
    case "low":
      return QUALITY_LOW;
    case "medium":
      return QUALITY_MEDIUM2;
    case "high":
      return QUALITY_HIGH;
    case "very-high":
      return QUALITY_VERY_HIGH;
    default:
      throw new Error(`Unsupported quality: ${quality}`);
  }
};
var getMimeType = (container) => {
  switch (container) {
    case "mp4":
      return "video/mp4";
    case "webm":
      return "video/webm";
    default:
      throw new Error(`Unsupported container: ${container}`);
  }
};

// src/render-operations-queue.ts
var onlyOneRenderAtATimeQueue = {
  ref: Promise.resolve()
};

// ../licensing/dist/esm/index.mjs
var HOST = "https://www.remotion.pro";
var registerUsageEvent = async ({
  apiKey,
  host,
  succeeded,
  event
}) => {
  const abortController = new AbortController;
  const timeout = setTimeout(() => {
    abortController.abort();
  }, 1e4);
  try {
    const res = await fetch(`${HOST}/api/track/register-usage-point`, {
      method: "POST",
      body: JSON.stringify({
        event,
        apiKey,
        host,
        succeeded
      }),
      headers: {
        "Content-Type": "application/json"
      },
      signal: abortController.signal
    });
    clearTimeout(timeout);
    const json = await res.json();
    if (json.success) {
      return {
        billable: json.billable,
        classification: json.classification
      };
    }
    if (!res.ok) {
      throw new Error(json.error);
    }
    const read = await res.json();
    return read;
  } catch (err) {
    clearTimeout(timeout);
    if (err instanceof Error && err.name === "AbortError") {
      throw new Error("Request timed out after 10 seconds");
    }
    throw err;
  }
};

// src/send-telemetry-event.ts
import { Internals as Internals3 } from "remotion";
var sendUsageEvent = async ({
  licenseKey,
  succeeded,
  apiName
}) => {
  const host = typeof window === "undefined" ? null : typeof window.location === "undefined" ? null : window.location.origin ?? null;
  if (host === null) {
    return;
  }
  if (licenseKey === null) {
    Internals3.Log.warn({ logLevel: "warn", tag: "web-renderer" }, `Pass "licenseKey" to ${apiName}(). If you qualify for the Free License (https://remotion.dev/license), pass "free-license" instead.`);
  }
  await registerUsageEvent({
    apiKey: licenseKey === "free-license" ? null : licenseKey,
    event: "webcodec-conversion",
    host,
    succeeded
  });
};

// src/drawing/turn-svg-into-drawable.ts
var turnSvgIntoDrawable = (svg) => {
  const { fill, color } = getComputedStyle(svg);
  const originalTransform = svg.style.transform;
  const originalTransformOrigin = svg.style.transformOrigin;
  const originalMarginLeft = svg.style.marginLeft;
  const originalMarginRight = svg.style.marginRight;
  const originalMarginTop = svg.style.marginTop;
  const originalMarginBottom = svg.style.marginBottom;
  const originalFill = svg.style.fill;
  const originalColor = svg.style.color;
  svg.style.transform = "none";
  svg.style.transformOrigin = "";
  svg.style.marginLeft = "0";
  svg.style.marginRight = "0";
  svg.style.marginTop = "0";
  svg.style.marginBottom = "0";
  svg.style.fill = fill;
  svg.style.color = color;
  const svgData = new XMLSerializer().serializeToString(svg);
  svg.style.marginLeft = originalMarginLeft;
  svg.style.marginRight = originalMarginRight;
  svg.style.marginTop = originalMarginTop;
  svg.style.marginBottom = originalMarginBottom;
  svg.style.transform = originalTransform;
  svg.style.transformOrigin = originalTransformOrigin;
  svg.style.fill = originalFill;
  svg.style.color = originalColor;
  return new Promise((resolve, reject) => {
    const image = new Image;
    const url = `data:image/svg+xml;base64,${btoa(svgData)}`;
    image.onload = function() {
      resolve(image);
    };
    image.onerror = () => {
      reject(new Error("Failed to convert SVG to image"));
    };
    image.src = url;
  });
};

// src/drawing/draw-dom-element.ts
var drawDomElement = (node) => {
  const domDrawFn = async ({ dimensions, contextToDraw }) => {
    const drawable = await (node instanceof SVGSVGElement ? turnSvgIntoDrawable(node) : node instanceof HTMLImageElement ? node : node instanceof HTMLCanvasElement ? node : null);
    if (!drawable) {
      return;
    }
    contextToDraw.drawImage(drawable, dimensions.left, dimensions.top, dimensions.width, dimensions.height);
  };
  return domDrawFn;
};

// src/drawing/process-node.ts
import { Internals as Internals5 } from "remotion";

// src/drawing/has-transform.ts
var hasTransformCssValue = (style) => {
  return style.transform !== "none" && style.transform !== "";
};
var hasRotateCssValue = (style) => {
  return style.rotate !== "none" && style.rotate !== "";
};
var hasScaleCssValue = (style) => {
  return style.scale !== "none" && style.scale !== "";
};
var hasAnyTransformCssValue = (style) => {
  return hasTransformCssValue(style) || hasRotateCssValue(style) || hasScaleCssValue(style);
};

// src/drawing/parse-linear-gradient.ts
import { NoReactInternals as NoReactInternals2 } from "remotion/no-react";
var isValidColor = (color) => {
  try {
    const result = NoReactInternals2.processColor(color);
    return result !== null && result !== undefined;
  } catch {
    return false;
  }
};
var parseDirection = (directionStr) => {
  const trimmed = directionStr.trim().toLowerCase();
  if (trimmed.startsWith("to ")) {
    const direction = trimmed.substring(3).trim();
    switch (direction) {
      case "top":
        return 0;
      case "right":
        return 90;
      case "bottom":
        return 180;
      case "left":
        return 270;
      case "top right":
      case "right top":
        return 45;
      case "bottom right":
      case "right bottom":
        return 135;
      case "bottom left":
      case "left bottom":
        return 225;
      case "top left":
      case "left top":
        return 315;
      default:
        return 180;
    }
  }
  const angleMatch = trimmed.match(/^(-?\d+\.?\d*)(deg|rad|grad|turn)$/);
  if (angleMatch) {
    const value = parseFloat(angleMatch[1]);
    const unit = angleMatch[2];
    switch (unit) {
      case "deg":
        return value;
      case "rad":
        return value * 180 / Math.PI;
      case "grad":
        return value * 360 / 400;
      case "turn":
        return value * 360;
      default:
        return value;
    }
  }
  return 180;
};
var parseColorStops = (colorStopsStr) => {
  const parts = colorStopsStr.split(/,(?![^(]*\))/);
  const stops = [];
  for (const part of parts) {
    const trimmed = part.trim();
    if (!trimmed)
      continue;
    const colorMatch = trimmed.match(/(rgba?\([^)]+\)|hsla?\([^)]+\)|#[0-9a-f]{3,8}|[a-z]+)/i);
    if (!colorMatch) {
      continue;
    }
    const colorStr = colorMatch[0];
    if (!isValidColor(colorStr)) {
      continue;
    }
    const remaining = trimmed.substring(colorMatch.index + colorStr.length).trim();
    const normalizedColor = colorStr;
    let position = null;
    if (remaining) {
      const posMatch = remaining.match(/(-?\d+\.?\d*)(%|px)?/);
      if (posMatch) {
        const value = parseFloat(posMatch[1]);
        const unit = posMatch[2];
        if (unit === "%") {
          position = value / 100;
        } else if (unit === "px") {
          position = null;
        } else {
          position = value / 100;
        }
      }
    }
    stops.push({
      color: normalizedColor,
      position: position !== null ? position : -1
    });
  }
  if (stops.length === 0) {
    return null;
  }
  let lastExplicitIndex = -1;
  let lastExplicitPosition = 0;
  for (let i = 0;i < stops.length; i++) {
    if (stops[i].position !== -1) {
      if (lastExplicitIndex >= 0) {
        const numImplicit = i - lastExplicitIndex - 1;
        if (numImplicit > 0) {
          const step = (stops[i].position - lastExplicitPosition) / (numImplicit + 1);
          for (let j = lastExplicitIndex + 1;j < i; j++) {
            stops[j].position = lastExplicitPosition + step * (j - lastExplicitIndex);
          }
        }
      } else {
        const numImplicit = i;
        if (numImplicit > 0) {
          const step = stops[i].position / (numImplicit + 1);
          for (let j = 0;j < i; j++) {
            stops[j].position = step * (j + 1);
          }
        }
      }
      lastExplicitIndex = i;
      lastExplicitPosition = stops[i].position;
    }
  }
  if (stops.every((s) => s.position === -1)) {
    if (stops.length === 1) {
      stops[0].position = 0.5;
    } else {
      for (let i = 0;i < stops.length; i++) {
        stops[i].position = i / (stops.length - 1);
      }
    }
  } else if (lastExplicitIndex < stops.length - 1) {
    const numImplicit = stops.length - 1 - lastExplicitIndex;
    const step = (1 - lastExplicitPosition) / (numImplicit + 1);
    for (let i = lastExplicitIndex + 1;i < stops.length; i++) {
      stops[i].position = lastExplicitPosition + step * (i - lastExplicitIndex);
    }
  }
  for (const stop of stops) {
    stop.position = Math.max(0, Math.min(1, stop.position));
  }
  return stops;
};
var extractGradientContent = (backgroundImage) => {
  const prefix = "linear-gradient(";
  const startIndex = backgroundImage.toLowerCase().indexOf(prefix);
  if (startIndex === -1) {
    return null;
  }
  let depth = 0;
  const contentStart = startIndex + prefix.length;
  for (let i = contentStart;i < backgroundImage.length; i++) {
    const char = backgroundImage[i];
    if (char === "(") {
      depth++;
    } else if (char === ")") {
      if (depth === 0) {
        return backgroundImage.substring(contentStart, i).trim();
      }
      depth--;
    }
  }
  return null;
};
var parseLinearGradient = (backgroundImage) => {
  if (!backgroundImage || backgroundImage === "none") {
    return null;
  }
  const content = extractGradientContent(backgroundImage);
  if (!content) {
    return null;
  }
  const parts = content.split(/,(?![^(]*\))/);
  let angle = 180;
  let colorStopsStart = 0;
  if (parts.length > 0) {
    const firstPart = parts[0].trim();
    const isDirection = firstPart.startsWith("to ") || /^-?\d+\.?\d*(deg|rad|grad|turn)$/.test(firstPart);
    if (isDirection) {
      angle = parseDirection(firstPart);
      colorStopsStart = 1;
    }
  }
  const colorStopsStr = parts.slice(colorStopsStart).join(",");
  const colorStops = parseColorStops(colorStopsStr);
  if (!colorStops || colorStops.length === 0) {
    return null;
  }
  return {
    angle,
    colorStops
  };
};
var createCanvasGradient = ({
  ctx,
  rect,
  gradientInfo
}) => {
  const angleRad = (gradientInfo.angle - 90) * Math.PI / 180;
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;
  const cos = Math.cos(angleRad);
  const sin = Math.sin(angleRad);
  const halfWidth = rect.width / 2;
  const halfHeight = rect.height / 2;
  let length = Math.abs(cos) * halfWidth + Math.abs(sin) * halfHeight;
  if (!Number.isFinite(length) || length === 0) {
    length = Math.sqrt(halfWidth ** 2 + halfHeight ** 2);
  }
  const x0 = centerX - cos * length;
  const y0 = centerY - sin * length;
  const x1 = centerX + cos * length;
  const y1 = centerY + sin * length;
  const gradient = ctx.createLinearGradient(x0, y0, x1, y1);
  for (const stop of gradientInfo.colorStops) {
    gradient.addColorStop(stop.position, stop.color);
  }
  return gradient;
};

// src/drawing/mask-image.ts
var getMaskImageValue = (computedStyle) => {
  const { maskImage, webkitMaskImage } = computedStyle;
  const value = maskImage || webkitMaskImage;
  if (!value || value === "none") {
    return null;
  }
  return value;
};
var parseMaskImage = (maskImageValue) => {
  return parseLinearGradient(maskImageValue);
};

// src/drawing/parse-transform-origin.ts
var parseTransformOrigin = (transformOrigin) => {
  if (transformOrigin.trim() === "") {
    return null;
  }
  const [x, y] = transformOrigin.split(" ");
  return { x: parseFloat(x), y: parseFloat(y) };
};

// src/drawing/calculate-transforms.ts
var getInternalTransformOrigin = (transform) => {
  const centerX = transform.boundingClientRect.width / 2;
  const centerY = transform.boundingClientRect.height / 2;
  const origin = parseTransformOrigin(transform.transformOrigin) ?? {
    x: centerX,
    y: centerY
  };
  return origin;
};
var getGlobalTransformOrigin = ({ transform }) => {
  const { x: originX, y: originY } = getInternalTransformOrigin(transform);
  return {
    x: originX + transform.boundingClientRect.left,
    y: originY + transform.boundingClientRect.top
  };
};
var calculateTransforms = ({
  element,
  rootElement
}) => {
  let parent = element;
  const transforms = [];
  const toReset = [];
  let opacity = 1;
  let elementComputedStyle = null;
  let maskImageInfo = null;
  while (parent) {
    const computedStyle = getComputedStyle(parent);
    if (parent === element) {
      elementComputedStyle = computedStyle;
      opacity = parseFloat(computedStyle.opacity);
      const maskImageValue = getMaskImageValue(computedStyle);
      maskImageInfo = maskImageValue ? parseMaskImage(maskImageValue) : null;
      const originalMaskImage = parent.style.maskImage;
      const originalWebkitMaskImage = parent.style.webkitMaskImage;
      parent.style.maskImage = "none";
      parent.style.webkitMaskImage = "none";
      const parentRef = parent;
      toReset.push(() => {
        parentRef.style.maskImage = originalMaskImage;
        parentRef.style.webkitMaskImage = originalWebkitMaskImage;
      });
    }
    if (hasAnyTransformCssValue(computedStyle) || parent === element) {
      const toParse = hasTransformCssValue(computedStyle) ? computedStyle.transform : undefined;
      const matrix = new DOMMatrix(toParse);
      const { transform, scale, rotate } = parent.style;
      const additionalMatrices = [];
      if (rotate !== "" && rotate !== "none") {
        additionalMatrices.push(new DOMMatrix(`rotate(${rotate})`));
      }
      if (scale !== "" && scale !== "none") {
        additionalMatrices.push(new DOMMatrix(`scale(${scale})`));
      }
      additionalMatrices.push(matrix);
      parent.style.transform = "none";
      parent.style.scale = "none";
      parent.style.rotate = "none";
      transforms.push({
        element: parent,
        transformOrigin: computedStyle.transformOrigin,
        boundingClientRect: null,
        matrices: additionalMatrices
      });
      const parentRef = parent;
      toReset.push(() => {
        parentRef.style.transform = transform;
        parentRef.style.scale = scale;
        parentRef.style.rotate = rotate;
      });
    }
    if (parent === rootElement) {
      break;
    }
    parent = parent.parentElement;
  }
  for (const transform of transforms) {
    transform.boundingClientRect = transform.element.getBoundingClientRect();
  }
  const dimensions = transforms[0].boundingClientRect;
  const nativeTransformOrigin = getInternalTransformOrigin(transforms[0]);
  const totalMatrix = new DOMMatrix;
  for (const transform of transforms.slice().reverse()) {
    for (const matrix of transform.matrices) {
      const globalTransformOrigin = getGlobalTransformOrigin({
        transform
      });
      const transformMatrix = new DOMMatrix().translate(globalTransformOrigin.x, globalTransformOrigin.y).multiply(matrix).translate(-globalTransformOrigin.x, -globalTransformOrigin.y);
      totalMatrix.multiplySelf(transformMatrix);
    }
  }
  if (!elementComputedStyle) {
    throw new Error("Element computed style not found");
  }
  const needs3DTransformViaWebGL = !totalMatrix.is2D;
  const needsMaskImage = maskImageInfo !== null;
  return {
    dimensions,
    totalMatrix,
    reset: () => {
      for (const reset of toReset) {
        reset();
      }
    },
    nativeTransformOrigin,
    computedStyle: elementComputedStyle,
    opacity,
    maskImageInfo,
    precompositing: {
      needs3DTransformViaWebGL,
      needsMaskImage: maskImageInfo,
      needsPrecompositing: Boolean(needs3DTransformViaWebGL || needsMaskImage)
    }
  };
};

// src/drawing/round-to-expand-rect.ts
var roundToExpandRect = (rect) => {
  const left = Math.floor(rect.left);
  const top = Math.floor(rect.top);
  const right = Math.ceil(rect.right);
  const bottom = Math.ceil(rect.bottom);
  return new DOMRect(left, top, right - left, bottom - top);
};

// src/drawing/clamp-rect-to-parent-bounds.ts
var getNarrowerRect = ({
  firstRect,
  secondRect
}) => {
  const left = Math.max(firstRect.left, secondRect.left);
  const top = Math.max(firstRect.top, secondRect.top);
  const bottom = Math.min(firstRect.bottom, secondRect.bottom);
  const right = Math.min(firstRect.right, secondRect.right);
  return new DOMRect(left, top, right - left, bottom - top);
};
var getWiderRectAndExpand = ({
  firstRect,
  secondRect
}) => {
  if (firstRect === null) {
    return roundToExpandRect(secondRect);
  }
  const left = Math.min(firstRect.left, secondRect.left);
  const top = Math.min(firstRect.top, secondRect.top);
  const bottom = Math.max(firstRect.bottom, secondRect.bottom);
  const right = Math.max(firstRect.right, secondRect.right);
  return roundToExpandRect(new DOMRect(left, top, right - left, bottom - top));
};

// src/drawing/do-rects-intersect.ts
function doRectsIntersect(rect1, rect2) {
  return !(rect1.right <= rect2.left || rect1.left >= rect2.right || rect1.bottom <= rect2.top || rect1.top >= rect2.bottom);
}

// src/drawing/draw-rounded.ts
var drawRoundedRectPath = ({
  ctx,
  x,
  y,
  width,
  height,
  borderRadius
}) => {
  ctx.beginPath();
  ctx.moveTo(x + borderRadius.topLeft.horizontal, y);
  ctx.lineTo(x + width - borderRadius.topRight.horizontal, y);
  if (borderRadius.topRight.horizontal > 0 || borderRadius.topRight.vertical > 0) {
    ctx.ellipse(x + width - borderRadius.topRight.horizontal, y + borderRadius.topRight.vertical, borderRadius.topRight.horizontal, borderRadius.topRight.vertical, 0, -Math.PI / 2, 0);
  }
  ctx.lineTo(x + width, y + height - borderRadius.bottomRight.vertical);
  if (borderRadius.bottomRight.horizontal > 0 || borderRadius.bottomRight.vertical > 0) {
    ctx.ellipse(x + width - borderRadius.bottomRight.horizontal, y + height - borderRadius.bottomRight.vertical, borderRadius.bottomRight.horizontal, borderRadius.bottomRight.vertical, 0, 0, Math.PI / 2);
  }
  ctx.lineTo(x + borderRadius.bottomLeft.horizontal, y + height);
  if (borderRadius.bottomLeft.horizontal > 0 || borderRadius.bottomLeft.vertical > 0) {
    ctx.ellipse(x + borderRadius.bottomLeft.horizontal, y + height - borderRadius.bottomLeft.vertical, borderRadius.bottomLeft.horizontal, borderRadius.bottomLeft.vertical, 0, Math.PI / 2, Math.PI);
  }
  ctx.lineTo(x, y + borderRadius.topLeft.vertical);
  if (borderRadius.topLeft.horizontal > 0 || borderRadius.topLeft.vertical > 0) {
    ctx.ellipse(x + borderRadius.topLeft.horizontal, y + borderRadius.topLeft.vertical, borderRadius.topLeft.horizontal, borderRadius.topLeft.vertical, 0, Math.PI, Math.PI * 3 / 2);
  }
  ctx.closePath();
};

// src/drawing/border-radius.ts
function parseValue({
  value,
  reference
}) {
  value = value.trim();
  if (value.endsWith("%")) {
    const percentage = parseFloat(value);
    return percentage / 100 * reference;
  }
  if (value.endsWith("px")) {
    return parseFloat(value);
  }
  return parseFloat(value);
}
function expandShorthand(values) {
  if (values.length === 1) {
    return [values[0], values[0], values[0], values[0]];
  }
  if (values.length === 2) {
    return [values[0], values[1], values[0], values[1]];
  }
  if (values.length === 3) {
    return [values[0], values[1], values[2], values[1]];
  }
  return [values[0], values[1], values[2], values[3]];
}
function clampBorderRadius({
  borderRadius,
  width,
  height
}) {
  const clamped = {
    topLeft: { ...borderRadius.topLeft },
    topRight: { ...borderRadius.topRight },
    bottomRight: { ...borderRadius.bottomRight },
    bottomLeft: { ...borderRadius.bottomLeft }
  };
  const topSum = clamped.topLeft.horizontal + clamped.topRight.horizontal;
  if (topSum > width) {
    const factor = width / topSum;
    clamped.topLeft.horizontal *= factor;
    clamped.topRight.horizontal *= factor;
  }
  const rightSum = clamped.topRight.vertical + clamped.bottomRight.vertical;
  if (rightSum > height) {
    const factor = height / rightSum;
    clamped.topRight.vertical *= factor;
    clamped.bottomRight.vertical *= factor;
  }
  const bottomSum = clamped.bottomRight.horizontal + clamped.bottomLeft.horizontal;
  if (bottomSum > width) {
    const factor = width / bottomSum;
    clamped.bottomRight.horizontal *= factor;
    clamped.bottomLeft.horizontal *= factor;
  }
  const leftSum = clamped.bottomLeft.vertical + clamped.topLeft.vertical;
  if (leftSum > height) {
    const factor = height / leftSum;
    clamped.bottomLeft.vertical *= factor;
    clamped.topLeft.vertical *= factor;
  }
  return clamped;
}
function parseBorderRadius({
  borderRadius,
  width,
  height
}) {
  const parts = borderRadius.split("/").map((part) => part.trim());
  const horizontalPart = parts[0];
  const verticalPart = parts[1];
  const horizontalValues = horizontalPart.split(/\s+/).filter((v) => v);
  const verticalValues = verticalPart ? verticalPart.split(/\s+/).filter((v) => v) : horizontalValues;
  const [hTopLeft, hTopRight, hBottomRight, hBottomLeft] = expandShorthand(horizontalValues);
  const [vTopLeft, vTopRight, vBottomRight, vBottomLeft] = expandShorthand(verticalValues);
  return clampBorderRadius({
    borderRadius: {
      topLeft: {
        horizontal: parseValue({ value: hTopLeft, reference: width }),
        vertical: parseValue({ value: vTopLeft, reference: height })
      },
      topRight: {
        horizontal: parseValue({ value: hTopRight, reference: width }),
        vertical: parseValue({ value: vTopRight, reference: height })
      },
      bottomRight: {
        horizontal: parseValue({ value: hBottomRight, reference: width }),
        vertical: parseValue({ value: vBottomRight, reference: height })
      },
      bottomLeft: {
        horizontal: parseValue({ value: hBottomLeft, reference: width }),
        vertical: parseValue({ value: vBottomLeft, reference: height })
      }
    },
    width,
    height
  });
}
function setBorderRadius({
  ctx,
  rect,
  borderRadius,
  forceClipEvenWhenZero = false
}) {
  if (borderRadius.topLeft.horizontal === 0 && borderRadius.topLeft.vertical === 0 && borderRadius.topRight.horizontal === 0 && borderRadius.topRight.vertical === 0 && borderRadius.bottomRight.horizontal === 0 && borderRadius.bottomRight.vertical === 0 && borderRadius.bottomLeft.horizontal === 0 && borderRadius.bottomLeft.vertical === 0 && !forceClipEvenWhenZero) {
    return () => {};
  }
  ctx.save();
  drawRoundedRectPath({
    ctx,
    x: rect.left,
    y: rect.top,
    width: rect.width,
    height: rect.height,
    borderRadius
  });
  ctx.clip();
  return () => {
    ctx.restore();
  };
}

// src/drawing/draw-border.ts
var parseBorderWidth = (value) => {
  return parseFloat(value) || 0;
};
var getBorderSideProperties = (computedStyle) => {
  return {
    top: {
      width: parseBorderWidth(computedStyle.borderTopWidth),
      color: computedStyle.borderTopColor || computedStyle.borderColor || "black",
      style: computedStyle.borderTopStyle || computedStyle.borderStyle || "solid"
    },
    right: {
      width: parseBorderWidth(computedStyle.borderRightWidth),
      color: computedStyle.borderRightColor || computedStyle.borderColor || "black",
      style: computedStyle.borderRightStyle || computedStyle.borderStyle || "solid"
    },
    bottom: {
      width: parseBorderWidth(computedStyle.borderBottomWidth),
      color: computedStyle.borderBottomColor || computedStyle.borderColor || "black",
      style: computedStyle.borderBottomStyle || computedStyle.borderStyle || "solid"
    },
    left: {
      width: parseBorderWidth(computedStyle.borderLeftWidth),
      color: computedStyle.borderLeftColor || computedStyle.borderColor || "black",
      style: computedStyle.borderLeftStyle || computedStyle.borderStyle || "solid"
    }
  };
};
var getLineDashPattern = (style, width) => {
  if (style === "dashed") {
    return [width * 2, width];
  }
  if (style === "dotted") {
    return [width, width];
  }
  return [];
};
var drawBorderSide = ({
  ctx,
  side,
  x,
  y,
  width,
  height,
  borderRadius,
  borderProperties
}) => {
  const { width: borderWidth, color, style } = borderProperties;
  if (borderWidth <= 0 || style === "none" || style === "hidden") {
    return;
  }
  ctx.beginPath();
  ctx.strokeStyle = color;
  ctx.lineWidth = borderWidth;
  ctx.setLineDash(getLineDashPattern(style, borderWidth));
  const halfWidth = borderWidth / 2;
  if (side === "top") {
    const startX = x + borderRadius.topLeft.horizontal;
    const startY = y + halfWidth;
    const endX = x + width - borderRadius.topRight.horizontal;
    const endY = y + halfWidth;
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
  } else if (side === "right") {
    const startX = x + width - halfWidth;
    const startY = y + borderRadius.topRight.vertical;
    const endX = x + width - halfWidth;
    const endY = y + height - borderRadius.bottomRight.vertical;
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
  } else if (side === "bottom") {
    const startX = x + borderRadius.bottomLeft.horizontal;
    const startY = y + height - halfWidth;
    const endX = x + width - borderRadius.bottomRight.horizontal;
    const endY = y + height - halfWidth;
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
  } else if (side === "left") {
    const startX = x + halfWidth;
    const startY = y + borderRadius.topLeft.vertical;
    const endX = x + halfWidth;
    const endY = y + height - borderRadius.bottomLeft.vertical;
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
  }
  ctx.stroke();
};
var drawCorner = ({
  ctx,
  corner,
  x,
  y,
  width,
  height,
  borderRadius,
  topBorder,
  rightBorder,
  bottomBorder,
  leftBorder
}) => {
  const radius = borderRadius[corner];
  if (radius.horizontal <= 0 && radius.vertical <= 0) {
    return;
  }
  let border1;
  let border2;
  let centerX;
  let centerY;
  let startAngle;
  let endAngle;
  if (corner === "topLeft") {
    border1 = leftBorder;
    border2 = topBorder;
    centerX = x + radius.horizontal;
    centerY = y + radius.vertical;
    startAngle = Math.PI;
    endAngle = Math.PI * 3 / 2;
  } else if (corner === "topRight") {
    border1 = topBorder;
    border2 = rightBorder;
    centerX = x + width - radius.horizontal;
    centerY = y + radius.vertical;
    startAngle = -Math.PI / 2;
    endAngle = 0;
  } else if (corner === "bottomRight") {
    border1 = rightBorder;
    border2 = bottomBorder;
    centerX = x + width - radius.horizontal;
    centerY = y + height - radius.vertical;
    startAngle = 0;
    endAngle = Math.PI / 2;
  } else {
    border1 = bottomBorder;
    border2 = leftBorder;
    centerX = x + radius.horizontal;
    centerY = y + height - radius.vertical;
    startAngle = Math.PI / 2;
    endAngle = Math.PI;
  }
  const avgWidth = (border1.width + border2.width) / 2;
  const useColor = border1.width >= border2.width ? border1.color : border2.color;
  const useStyle = border1.width >= border2.width ? border1.style : border2.style;
  if (avgWidth > 0 && useStyle !== "none" && useStyle !== "hidden") {
    ctx.beginPath();
    ctx.strokeStyle = useColor;
    ctx.lineWidth = avgWidth;
    ctx.setLineDash(getLineDashPattern(useStyle, avgWidth));
    const adjustedRadiusH = Math.max(0, radius.horizontal - avgWidth / 2);
    const adjustedRadiusV = Math.max(0, radius.vertical - avgWidth / 2);
    ctx.ellipse(centerX, centerY, adjustedRadiusH, adjustedRadiusV, 0, startAngle, endAngle);
    ctx.stroke();
  }
};
var drawUniformBorder = ({
  ctx,
  x,
  y,
  width,
  height,
  borderRadius,
  borderWidth,
  borderColor,
  borderStyle
}) => {
  ctx.beginPath();
  ctx.strokeStyle = borderColor;
  ctx.lineWidth = borderWidth;
  ctx.setLineDash(getLineDashPattern(borderStyle, borderWidth));
  const halfWidth = borderWidth / 2;
  const borderX = x + halfWidth;
  const borderY = y + halfWidth;
  const borderW = width - borderWidth;
  const borderH = height - borderWidth;
  const adjustedBorderRadius = {
    topLeft: {
      horizontal: Math.max(0, borderRadius.topLeft.horizontal - halfWidth),
      vertical: Math.max(0, borderRadius.topLeft.vertical - halfWidth)
    },
    topRight: {
      horizontal: Math.max(0, borderRadius.topRight.horizontal - halfWidth),
      vertical: Math.max(0, borderRadius.topRight.vertical - halfWidth)
    },
    bottomRight: {
      horizontal: Math.max(0, borderRadius.bottomRight.horizontal - halfWidth),
      vertical: Math.max(0, borderRadius.bottomRight.vertical - halfWidth)
    },
    bottomLeft: {
      horizontal: Math.max(0, borderRadius.bottomLeft.horizontal - halfWidth),
      vertical: Math.max(0, borderRadius.bottomLeft.vertical - halfWidth)
    }
  };
  ctx.moveTo(borderX + adjustedBorderRadius.topLeft.horizontal, borderY);
  ctx.lineTo(borderX + borderW - adjustedBorderRadius.topRight.horizontal, borderY);
  if (adjustedBorderRadius.topRight.horizontal > 0 || adjustedBorderRadius.topRight.vertical > 0) {
    ctx.ellipse(borderX + borderW - adjustedBorderRadius.topRight.horizontal, borderY + adjustedBorderRadius.topRight.vertical, adjustedBorderRadius.topRight.horizontal, adjustedBorderRadius.topRight.vertical, 0, -Math.PI / 2, 0);
  }
  ctx.lineTo(borderX + borderW, borderY + borderH - adjustedBorderRadius.bottomRight.vertical);
  if (adjustedBorderRadius.bottomRight.horizontal > 0 || adjustedBorderRadius.bottomRight.vertical > 0) {
    ctx.ellipse(borderX + borderW - adjustedBorderRadius.bottomRight.horizontal, borderY + borderH - adjustedBorderRadius.bottomRight.vertical, adjustedBorderRadius.bottomRight.horizontal, adjustedBorderRadius.bottomRight.vertical, 0, 0, Math.PI / 2);
  }
  ctx.lineTo(borderX + adjustedBorderRadius.bottomLeft.horizontal, borderY + borderH);
  if (adjustedBorderRadius.bottomLeft.horizontal > 0 || adjustedBorderRadius.bottomLeft.vertical > 0) {
    ctx.ellipse(borderX + adjustedBorderRadius.bottomLeft.horizontal, borderY + borderH - adjustedBorderRadius.bottomLeft.vertical, adjustedBorderRadius.bottomLeft.horizontal, adjustedBorderRadius.bottomLeft.vertical, 0, Math.PI / 2, Math.PI);
  }
  ctx.lineTo(borderX, borderY + adjustedBorderRadius.topLeft.vertical);
  if (adjustedBorderRadius.topLeft.horizontal > 0 || adjustedBorderRadius.topLeft.vertical > 0) {
    ctx.ellipse(borderX + adjustedBorderRadius.topLeft.horizontal, borderY + adjustedBorderRadius.topLeft.vertical, adjustedBorderRadius.topLeft.horizontal, adjustedBorderRadius.topLeft.vertical, 0, Math.PI, Math.PI * 3 / 2);
  }
  ctx.closePath();
  ctx.stroke();
};
var drawBorder = ({
  ctx,
  rect,
  borderRadius,
  computedStyle
}) => {
  const borders = getBorderSideProperties(computedStyle);
  const hasBorder = borders.top.width > 0 || borders.right.width > 0 || borders.bottom.width > 0 || borders.left.width > 0;
  if (!hasBorder) {
    return;
  }
  const originalStrokeStyle = ctx.strokeStyle;
  const originalLineWidth = ctx.lineWidth;
  const originalLineDash = ctx.getLineDash();
  const allSidesEqual = borders.top.width === borders.right.width && borders.top.width === borders.bottom.width && borders.top.width === borders.left.width && borders.top.color === borders.right.color && borders.top.color === borders.bottom.color && borders.top.color === borders.left.color && borders.top.style === borders.right.style && borders.top.style === borders.bottom.style && borders.top.style === borders.left.style && borders.top.width > 0;
  if (allSidesEqual) {
    drawUniformBorder({
      ctx,
      x: rect.left,
      y: rect.top,
      width: rect.width,
      height: rect.height,
      borderRadius,
      borderWidth: borders.top.width,
      borderColor: borders.top.color,
      borderStyle: borders.top.style
    });
  } else {
    drawCorner({
      ctx,
      corner: "topLeft",
      x: rect.left,
      y: rect.top,
      width: rect.width,
      height: rect.height,
      borderRadius,
      topBorder: borders.top,
      rightBorder: borders.right,
      bottomBorder: borders.bottom,
      leftBorder: borders.left
    });
    drawCorner({
      ctx,
      corner: "topRight",
      x: rect.left,
      y: rect.top,
      width: rect.width,
      height: rect.height,
      borderRadius,
      topBorder: borders.top,
      rightBorder: borders.right,
      bottomBorder: borders.bottom,
      leftBorder: borders.left
    });
    drawCorner({
      ctx,
      corner: "bottomRight",
      x: rect.left,
      y: rect.top,
      width: rect.width,
      height: rect.height,
      borderRadius,
      topBorder: borders.top,
      rightBorder: borders.right,
      bottomBorder: borders.bottom,
      leftBorder: borders.left
    });
    drawCorner({
      ctx,
      corner: "bottomLeft",
      x: rect.left,
      y: rect.top,
      width: rect.width,
      height: rect.height,
      borderRadius,
      topBorder: borders.top,
      rightBorder: borders.right,
      bottomBorder: borders.bottom,
      leftBorder: borders.left
    });
    drawBorderSide({
      ctx,
      side: "top",
      x: rect.left,
      y: rect.top,
      width: rect.width,
      height: rect.height,
      borderRadius,
      borderProperties: borders.top
    });
    drawBorderSide({
      ctx,
      side: "right",
      x: rect.left,
      y: rect.top,
      width: rect.width,
      height: rect.height,
      borderRadius,
      borderProperties: borders.right
    });
    drawBorderSide({
      ctx,
      side: "bottom",
      x: rect.left,
      y: rect.top,
      width: rect.width,
      height: rect.height,
      borderRadius,
      borderProperties: borders.bottom
    });
    drawBorderSide({
      ctx,
      side: "left",
      x: rect.left,
      y: rect.top,
      width: rect.width,
      height: rect.height,
      borderRadius,
      borderProperties: borders.left
    });
  }
  ctx.strokeStyle = originalStrokeStyle;
  ctx.lineWidth = originalLineWidth;
  ctx.setLineDash(originalLineDash);
};

// src/drawing/draw-box-shadow.ts
import { Internals as Internals4 } from "remotion";
var parseBoxShadow = (boxShadowValue) => {
  if (!boxShadowValue || boxShadowValue === "none") {
    return [];
  }
  const shadows = [];
  const shadowStrings = boxShadowValue.split(/,(?![^(]*\))/);
  for (const shadowStr of shadowStrings) {
    const trimmed = shadowStr.trim();
    if (!trimmed || trimmed === "none") {
      continue;
    }
    const shadow = {
      offsetX: 0,
      offsetY: 0,
      blurRadius: 0,
      color: "rgba(0, 0, 0, 0.5)",
      inset: false
    };
    shadow.inset = /\binset\b/i.test(trimmed);
    let remaining = trimmed.replace(/\binset\b/gi, "").trim();
    const colorMatch = remaining.match(/(rgba?\([^)]+\)|hsla?\([^)]+\)|#[0-9a-f]{3,8}|[a-z]+)/i);
    if (colorMatch) {
      shadow.color = colorMatch[0];
      remaining = remaining.replace(colorMatch[0], "").trim();
    }
    const numbers = remaining.match(/[+-]?\d*\.?\d+(?:px|em|rem|%)?/gi) || [];
    const values = numbers.map((n) => parseFloat(n) || 0);
    if (values.length >= 2) {
      shadow.offsetX = values[0];
      shadow.offsetY = values[1];
      if (values.length >= 3) {
        shadow.blurRadius = Math.max(0, values[2]);
      }
    }
    shadows.push(shadow);
  }
  return shadows;
};
var setBoxShadow = ({
  ctx,
  rect,
  borderRadius,
  computedStyle,
  logLevel
}) => {
  const shadows = parseBoxShadow(computedStyle.boxShadow);
  if (shadows.length === 0) {
    return;
  }
  for (let i = shadows.length - 1;i >= 0; i--) {
    const shadow = shadows[i];
    const newLeft = rect.left + Math.min(shadow.offsetX, 0) - shadow.blurRadius;
    const newRight = rect.right + Math.max(shadow.offsetX, 0) + shadow.blurRadius;
    const newTop = rect.top + Math.min(shadow.offsetY, 0) - shadow.blurRadius;
    const newBottom = rect.bottom + Math.max(shadow.offsetY, 0) + shadow.blurRadius;
    const newRect = new DOMRect(newLeft, newTop, newRight - newLeft, newBottom - newTop);
    const leftOffset = rect.left - newLeft;
    const topOffset = rect.top - newTop;
    const newCanvas = new OffscreenCanvas(newRect.width, newRect.height);
    const newCtx = newCanvas.getContext("2d");
    if (!newCtx) {
      throw new Error("Failed to get context");
    }
    if (shadow.inset) {
      Internals4.Log.warn({
        logLevel,
        tag: "@remotion/web-renderer"
      }, 'Detected "box-shadow" with "inset". This is not yet supported in @remotion/web-renderer');
      continue;
    }
    newCtx.shadowBlur = shadow.blurRadius;
    newCtx.shadowColor = shadow.color;
    newCtx.shadowOffsetX = shadow.offsetX;
    newCtx.shadowOffsetY = shadow.offsetY;
    newCtx.fillStyle = "black";
    drawRoundedRectPath({
      ctx: newCtx,
      x: leftOffset,
      y: topOffset,
      width: rect.width,
      height: rect.height,
      borderRadius
    });
    newCtx.fill();
    newCtx.shadowColor = "transparent";
    newCtx.globalCompositeOperation = "destination-out";
    drawRoundedRectPath({
      ctx: newCtx,
      x: leftOffset,
      y: topOffset,
      width: rect.width,
      height: rect.height,
      borderRadius
    });
    newCtx.fill();
    ctx.drawImage(newCanvas, rect.left - leftOffset, rect.top - topOffset);
  }
};

// src/drawing/draw-outline.ts
var parseOutlineWidth = (value) => {
  return parseFloat(value) || 0;
};
var parseOutlineOffset = (value) => {
  return parseFloat(value) || 0;
};
var getLineDashPattern2 = (style, width) => {
  if (style === "dashed") {
    return [width * 2, width];
  }
  if (style === "dotted") {
    return [width, width];
  }
  return [];
};
var drawOutline = ({
  ctx,
  rect,
  borderRadius,
  computedStyle
}) => {
  const outlineWidth = parseOutlineWidth(computedStyle.outlineWidth);
  const { outlineStyle } = computedStyle;
  const outlineColor = computedStyle.outlineColor || "black";
  const outlineOffset = parseOutlineOffset(computedStyle.outlineOffset);
  if (outlineWidth <= 0 || outlineStyle === "none" || outlineStyle === "hidden") {
    return;
  }
  const originalStrokeStyle = ctx.strokeStyle;
  const originalLineWidth = ctx.lineWidth;
  const originalLineDash = ctx.getLineDash();
  ctx.strokeStyle = outlineColor;
  ctx.lineWidth = outlineWidth;
  ctx.setLineDash(getLineDashPattern2(outlineStyle, outlineWidth));
  const halfWidth = outlineWidth / 2;
  const offset = outlineOffset + halfWidth;
  const outlineX = rect.left - offset;
  const outlineY = rect.top - offset;
  const outlineW = rect.width + offset * 2;
  const outlineH = rect.height + offset * 2;
  const adjustedBorderRadius = {
    topLeft: {
      horizontal: borderRadius.topLeft.horizontal === 0 ? 0 : Math.max(0, borderRadius.topLeft.horizontal + offset),
      vertical: borderRadius.topLeft.vertical === 0 ? 0 : Math.max(0, borderRadius.topLeft.vertical + offset)
    },
    topRight: {
      horizontal: borderRadius.topRight.horizontal === 0 ? 0 : Math.max(0, borderRadius.topRight.horizontal + offset),
      vertical: borderRadius.topRight.vertical === 0 ? 0 : Math.max(0, borderRadius.topRight.vertical + offset)
    },
    bottomRight: {
      horizontal: borderRadius.bottomRight.horizontal === 0 ? 0 : Math.max(0, borderRadius.bottomRight.horizontal + offset),
      vertical: borderRadius.bottomRight.vertical === 0 ? 0 : Math.max(0, borderRadius.bottomRight.vertical + offset)
    },
    bottomLeft: {
      horizontal: borderRadius.bottomLeft.horizontal === 0 ? 0 : Math.max(0, borderRadius.bottomLeft.horizontal + offset),
      vertical: borderRadius.bottomLeft.vertical === 0 ? 0 : Math.max(0, borderRadius.bottomLeft.vertical + offset)
    }
  };
  drawRoundedRectPath({
    ctx,
    x: outlineX,
    y: outlineY,
    width: outlineW,
    height: outlineH,
    borderRadius: adjustedBorderRadius
  });
  ctx.stroke();
  ctx.strokeStyle = originalStrokeStyle;
  ctx.lineWidth = originalLineWidth;
  ctx.setLineDash(originalLineDash);
};

// src/drawing/opacity.ts
var setOpacity = ({
  ctx,
  opacity
}) => {
  const previousAlpha = ctx.globalAlpha;
  ctx.globalAlpha = previousAlpha * opacity;
  return () => {
    ctx.globalAlpha = previousAlpha;
  };
};

// src/drawing/overflow.ts
var setOverflowHidden = ({
  ctx,
  rect,
  borderRadius,
  overflowHidden
}) => {
  if (!overflowHidden) {
    return () => {};
  }
  return setBorderRadius({
    ctx,
    rect,
    borderRadius,
    forceClipEvenWhenZero: true
  });
};

// src/drawing/transform.ts
var setTransform = ({
  ctx,
  transform,
  parentRect
}) => {
  const offsetMatrix = new DOMMatrix().translate(-parentRect.x, -parentRect.y).multiply(transform).translate(parentRect.x, parentRect.y);
  ctx.setTransform(offsetMatrix);
  return () => {
    ctx.setTransform(new DOMMatrix);
  };
};

// src/drawing/draw-element.ts
var drawElement = async ({
  rect,
  computedStyle,
  context,
  draw,
  opacity,
  totalMatrix,
  parentRect,
  logLevel
}) => {
  const background = computedStyle.backgroundColor;
  const { backgroundImage } = computedStyle;
  const borderRadius = parseBorderRadius({
    borderRadius: computedStyle.borderRadius,
    width: rect.width,
    height: rect.height
  });
  const finishTransform = setTransform({
    ctx: context,
    transform: totalMatrix,
    parentRect
  });
  const finishOpacity = setOpacity({
    ctx: context,
    opacity
  });
  setBoxShadow({
    ctx: context,
    computedStyle,
    rect,
    borderRadius,
    logLevel
  });
  const finishBorderRadius = setBorderRadius({
    ctx: context,
    rect,
    borderRadius,
    forceClipEvenWhenZero: false
  });
  let gradientDrawn = false;
  if (backgroundImage && backgroundImage !== "none") {
    const gradientInfo = parseLinearGradient(backgroundImage);
    if (gradientInfo) {
      const gradient = createCanvasGradient({
        ctx: context,
        rect,
        gradientInfo
      });
      const originalFillStyle = context.fillStyle;
      context.fillStyle = gradient;
      context.fillRect(rect.left, rect.top, rect.width, rect.height);
      context.fillStyle = originalFillStyle;
      gradientDrawn = true;
    }
  }
  if (!gradientDrawn && background && background !== "transparent" && !(background.startsWith("rgba") && (background.endsWith(", 0)") || background.endsWith(",0")))) {
    const originalFillStyle = context.fillStyle;
    context.fillStyle = background;
    context.fillRect(rect.left, rect.top, rect.width, rect.height);
    context.fillStyle = originalFillStyle;
  }
  await draw({ dimensions: rect, computedStyle, contextToDraw: context });
  drawBorder({
    ctx: context,
    rect,
    borderRadius,
    computedStyle
  });
  finishBorderRadius();
  drawOutline({
    ctx: context,
    rect,
    borderRadius,
    computedStyle
  });
  const finishOverflowHidden = setOverflowHidden({
    ctx: context,
    rect,
    borderRadius,
    overflowHidden: computedStyle.overflow === "hidden"
  });
  finishTransform();
  return {
    cleanupAfterChildren: () => {
      finishOpacity();
      finishOverflowHidden();
    }
  };
};

// src/walk-tree.ts
function skipToNextNonDescendant(treeWalker) {
  if (treeWalker.nextSibling()) {
    return true;
  }
  while (treeWalker.parentNode()) {
    if (treeWalker.nextSibling()) {
      return true;
    }
  }
  return false;
}

// src/get-biggest-bounding-client-rect.ts
var getBiggestBoundingClientRect = (element) => {
  const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT);
  let mostLeft = Infinity;
  let mostTop = Infinity;
  let mostRight = -Infinity;
  let mostBottom = -Infinity;
  while (true) {
    const computedStyle = getComputedStyle(treeWalker.currentNode);
    const outlineWidth = parseOutlineWidth(computedStyle.outlineWidth);
    const outlineOffset = parseOutlineOffset(computedStyle.outlineOffset);
    const rect = treeWalker.currentNode.getBoundingClientRect();
    const shadows = parseBoxShadow(computedStyle.boxShadow);
    let shadowLeft = 0;
    let shadowRight = 0;
    let shadowTop = 0;
    let shadowBottom = 0;
    for (const shadow of shadows) {
      if (!shadow.inset) {
        shadowLeft = Math.max(shadowLeft, Math.abs(Math.min(shadow.offsetX, 0)) + shadow.blurRadius);
        shadowRight = Math.max(shadowRight, Math.max(shadow.offsetX, 0) + shadow.blurRadius);
        shadowTop = Math.max(shadowTop, Math.abs(Math.min(shadow.offsetY, 0)) + shadow.blurRadius);
        shadowBottom = Math.max(shadowBottom, Math.max(shadow.offsetY, 0) + shadow.blurRadius);
      }
    }
    mostLeft = Math.min(mostLeft, rect.left - outlineOffset - outlineWidth - shadowLeft);
    mostTop = Math.min(mostTop, rect.top - outlineOffset - outlineWidth - shadowTop);
    mostRight = Math.max(mostRight, rect.right + outlineOffset + outlineWidth + shadowRight);
    mostBottom = Math.max(mostBottom, rect.bottom + outlineOffset + outlineWidth + shadowBottom);
    if (computedStyle.overflow === "hidden") {
      if (!skipToNextNonDescendant(treeWalker)) {
        break;
      }
    }
    if (!treeWalker.nextNode()) {
      break;
    }
  }
  return new DOMRect(mostLeft, mostTop, mostRight - mostLeft, mostBottom - mostTop);
};

// src/drawing/get-pretransform-rect.ts
function getPreTransformRect(targetRect, matrix) {
  const origin = new DOMPoint(0, 0).matrixTransform(matrix);
  const unitX = new DOMPoint(1, 0).matrixTransform(matrix);
  const unitY = new DOMPoint(0, 1).matrixTransform(matrix);
  const basisX = { x: unitX.x - origin.x, y: unitX.y - origin.y };
  const basisY = { x: unitY.x - origin.x, y: unitY.y - origin.y };
  const effective2D = new DOMMatrix([
    basisX.x,
    basisX.y,
    basisY.x,
    basisY.y,
    origin.x,
    origin.y
  ]);
  const inverse2D = effective2D.inverse();
  const wasNotInvertible = isNaN(inverse2D.m11);
  if (wasNotInvertible) {
    return new DOMRect(0, 0, 0, 0);
  }
  const corners = [
    new DOMPoint(targetRect.x, targetRect.y),
    new DOMPoint(targetRect.x + targetRect.width, targetRect.y),
    new DOMPoint(targetRect.x + targetRect.width, targetRect.y + targetRect.height),
    new DOMPoint(targetRect.x, targetRect.y + targetRect.height)
  ];
  const transformedCorners = corners.map((c) => c.matrixTransform(inverse2D));
  const xs = transformedCorners.map((p) => p.x);
  const ys = transformedCorners.map((p) => p.y);
  return new DOMRect(Math.min(...xs), Math.min(...ys), Math.max(...xs) - Math.min(...xs), Math.max(...ys) - Math.min(...ys));
}

// src/drawing/transform-in-3d.ts
function compileShader(shaderGl, source, type) {
  const shader = shaderGl.createShader(type);
  if (!shader) {
    throw new Error("Could not create shader");
  }
  shaderGl.shaderSource(shader, source);
  shaderGl.compileShader(shader);
  if (!shaderGl.getShaderParameter(shader, shaderGl.COMPILE_STATUS)) {
    const log = shaderGl.getShaderInfoLog(shader);
    shaderGl.deleteShader(shader);
    throw new Error("Shader compile error: " + log);
  }
  return shader;
}
var createHelperCanvas = ({
  canvasWidth,
  canvasHeight
}) => {
  const canvas = new OffscreenCanvas(canvasWidth, canvasHeight);
  const gl = canvas.getContext("webgl", {
    premultipliedAlpha: true
  });
  if (!gl) {
    throw new Error("WebGL not supported");
  }
  const vsSource = `
        attribute vec2 aPosition;
        attribute vec2 aTexCoord;
        uniform mat4 uTransform;
        uniform mat4 uProjection;
        varying vec2 vTexCoord;

        void main() {
            gl_Position = uProjection * uTransform * vec4(aPosition, 0.0, 1.0);
            vTexCoord = aTexCoord;
        }
    `;
  const fsSource = `
        precision mediump float;
        uniform sampler2D uTexture;
        varying vec2 vTexCoord;

        void main() {
            gl_FragColor = texture2D(uTexture, vTexCoord);
        }
    `;
  const vertexShader = compileShader(gl, vsSource, gl.VERTEX_SHADER);
  const fragmentShader = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    throw new Error("Program link error: " + gl.getProgramInfoLog(program));
  }
  gl.useProgram(program);
  gl.clearColor(0, 0, 0, 0);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  return { canvas, gl, program, vertexShader, fragmentShader };
};
var transformIn3d = ({
  matrix,
  sourceCanvas,
  untransformedRect,
  rectAfterTransforms
}) => {
  const { canvas, gl, program } = createHelperCanvas({
    canvasWidth: rectAfterTransforms.width,
    canvasHeight: rectAfterTransforms.height
  });
  const vertexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  const vertices = new Float32Array([
    untransformedRect.x,
    untransformedRect.y,
    0,
    0,
    untransformedRect.x + untransformedRect.width,
    untransformedRect.y,
    1,
    0,
    untransformedRect.x,
    untransformedRect.y + untransformedRect.height,
    0,
    1,
    untransformedRect.x,
    untransformedRect.y + untransformedRect.height,
    0,
    1,
    untransformedRect.x + untransformedRect.width,
    untransformedRect.y,
    1,
    0,
    untransformedRect.x + untransformedRect.width,
    untransformedRect.y + untransformedRect.height,
    1,
    1
  ]);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  const aPosition = gl.getAttribLocation(program, "aPosition");
  const aTexCoord = gl.getAttribLocation(program, "aTexCoord");
  gl.enableVertexAttribArray(aPosition);
  gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 4 * 4, 0);
  gl.enableVertexAttribArray(aTexCoord);
  gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 4 * 4, 2 * 4);
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, sourceCanvas);
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
  const transformMatrix = matrix.toFloat32Array();
  const zScale = 1e9;
  const projectionMatrix = new Float32Array([
    2 / canvas.width,
    0,
    0,
    0,
    0,
    -2 / canvas.height,
    0,
    0,
    0,
    0,
    -2 / zScale,
    0,
    -1 + 2 * -rectAfterTransforms.x / canvas.width,
    1 - 2 * -rectAfterTransforms.y / canvas.height,
    0,
    1
  ]);
  const uTransform = gl.getUniformLocation(program, "uTransform");
  const uProjection = gl.getUniformLocation(program, "uProjection");
  const uTexture = gl.getUniformLocation(program, "uTexture");
  gl.uniformMatrix4fv(uTransform, false, transformMatrix);
  gl.uniformMatrix4fv(uProjection, false, projectionMatrix);
  gl.uniform1i(uTexture, 0);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  gl.disableVertexAttribArray(aPosition);
  gl.disableVertexAttribArray(aTexCoord);
  gl.deleteTexture(texture);
  gl.deleteBuffer(vertexBuffer);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.deleteTexture(texture);
  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  return {
    canvas,
    rect: rectAfterTransforms,
    cleanup: () => {
      const loseContext = gl.getExtension("WEBGL_lose_context");
      if (loseContext) {
        loseContext.loseContext();
      }
    }
  };
};

// src/drawing/handle-3d-transform.ts
var getPrecomposeRectFor3DTransform = ({
  element,
  parentRect,
  matrix
}) => {
  const unclampedBiggestBoundingClientRect = getBiggestBoundingClientRect(element);
  const biggestPossiblePretransformRect = getPreTransformRect(parentRect, matrix);
  const preTransformRect = getNarrowerRect({
    firstRect: unclampedBiggestBoundingClientRect,
    secondRect: biggestPossiblePretransformRect
  });
  return preTransformRect;
};
var handle3dTransform = ({
  matrix,
  precomposeRect,
  tempCanvas,
  rectAfterTransforms
}) => {
  const {
    canvas: transformed,
    rect: transformedRect,
    cleanup
  } = transformIn3d({
    untransformedRect: precomposeRect,
    matrix,
    sourceCanvas: tempCanvas,
    rectAfterTransforms
  });
  if (transformedRect.width <= 0 || transformedRect.height <= 0) {
    return null;
  }
  return [transformed, cleanup];
};

// src/drawing/handle-mask.ts
var getPrecomposeRectForMask = (element) => {
  const boundingRect = getBiggestBoundingClientRect(element);
  return boundingRect;
};
var handleMask = ({
  gradientInfo,
  rect,
  precomposeRect,
  tempContext
}) => {
  const rectOffsetX = rect.left - precomposeRect.left;
  const rectOffsetY = rect.top - precomposeRect.top;
  const rectToFill = new DOMRect(rectOffsetX, rectOffsetY, rect.width, rect.height);
  const gradient = createCanvasGradient({
    ctx: tempContext,
    rect: rectToFill,
    gradientInfo
  });
  tempContext.globalCompositeOperation = "destination-in";
  tempContext.fillStyle = gradient;
  tempContext.fillRect(rectToFill.left, rectToFill.top, rectToFill.width, rectToFill.height);
};

// src/drawing/precompose.ts
var precomposeDOMElement = async ({
  boundingRect,
  element,
  logLevel,
  internalState
}) => {
  const tempCanvas = new OffscreenCanvas(boundingRect.width, boundingRect.height);
  const tempContext = tempCanvas.getContext("2d");
  await compose({
    element,
    context: tempContext,
    logLevel,
    parentRect: boundingRect,
    internalState
  });
  return { tempCanvas, tempContext };
};

// src/drawing/transform-rect-with-matrix.ts
function transformDOMRect({
  rect,
  matrix
}) {
  const topLeft = new DOMPointReadOnly(rect.left, rect.top);
  const topRight = new DOMPointReadOnly(rect.right, rect.top);
  const bottomLeft = new DOMPointReadOnly(rect.left, rect.bottom);
  const bottomRight = new DOMPointReadOnly(rect.right, rect.bottom);
  const transformedTopLeft = topLeft.matrixTransform(matrix);
  const transformedTopRight = topRight.matrixTransform(matrix);
  const transformedBottomLeft = bottomLeft.matrixTransform(matrix);
  const transformedBottomRight = bottomRight.matrixTransform(matrix);
  const minX = Math.min(transformedTopLeft.x / transformedTopLeft.w, transformedTopRight.x / transformedTopRight.w, transformedBottomLeft.x / transformedBottomLeft.w, transformedBottomRight.x / transformedBottomRight.w);
  const maxX = Math.max(transformedTopLeft.x / transformedTopLeft.w, transformedTopRight.x / transformedTopRight.w, transformedBottomLeft.x / transformedBottomLeft.w, transformedBottomRight.x / transformedBottomRight.w);
  const minY = Math.min(transformedTopLeft.y / transformedTopLeft.w, transformedTopRight.y / transformedTopRight.w, transformedBottomLeft.y / transformedBottomLeft.w, transformedBottomRight.y / transformedBottomRight.w);
  const maxY = Math.max(transformedTopLeft.y / transformedTopLeft.w, transformedTopRight.y / transformedTopRight.w, transformedBottomLeft.y / transformedBottomLeft.w, transformedBottomRight.y / transformedBottomRight.w);
  return new DOMRect(minX, minY, maxX - minX, maxY - minY);
}

// src/drawing/process-node.ts
var processNode = async ({
  element,
  context,
  draw,
  logLevel,
  parentRect,
  internalState,
  rootElement
}) => {
  const {
    totalMatrix,
    reset,
    dimensions,
    opacity,
    computedStyle,
    precompositing
  } = calculateTransforms({
    element,
    rootElement
  });
  if (opacity === 0) {
    reset();
    return { type: "skip-children" };
  }
  if (dimensions.width <= 0 || dimensions.height <= 0) {
    reset();
    return { type: "continue", cleanupAfterChildren: null };
  }
  const rect = new DOMRect(dimensions.left - parentRect.x, dimensions.top - parentRect.y, dimensions.width, dimensions.height);
  if (precompositing.needsPrecompositing) {
    const start = Date.now();
    let precomposeRect = null;
    if (precompositing.needsMaskImage) {
      precomposeRect = getWiderRectAndExpand({
        firstRect: precomposeRect,
        secondRect: getPrecomposeRectForMask(element)
      });
    }
    if (precompositing.needs3DTransformViaWebGL) {
      precomposeRect = getWiderRectAndExpand({
        firstRect: precomposeRect,
        secondRect: getPrecomposeRectFor3DTransform({
          element,
          parentRect,
          matrix: totalMatrix
        })
      });
    }
    if (!precomposeRect) {
      throw new Error("Precompose rect not found");
    }
    if (precomposeRect.width <= 0 || precomposeRect.height <= 0) {
      return { type: "continue", cleanupAfterChildren: null };
    }
    if (!doRectsIntersect(precomposeRect, parentRect)) {
      return { type: "continue", cleanupAfterChildren: null };
    }
    const { tempCanvas, tempContext } = await precomposeDOMElement({
      boundingRect: precomposeRect,
      element,
      logLevel,
      internalState
    });
    let drawable = tempCanvas;
    let cleanupWebGL = () => {};
    const rectAfterTransforms = roundToExpandRect(transformDOMRect({
      rect: precomposeRect,
      matrix: totalMatrix
    }));
    if (precompositing.needsMaskImage) {
      handleMask({
        gradientInfo: precompositing.needsMaskImage,
        rect,
        precomposeRect,
        tempContext
      });
    }
    if (precompositing.needs3DTransformViaWebGL) {
      const t = handle3dTransform({
        matrix: totalMatrix,
        precomposeRect,
        tempCanvas: drawable,
        rectAfterTransforms
      });
      if (t) {
        const [transformed, cleanup] = t;
        drawable = transformed;
        cleanupWebGL = cleanup;
      }
    }
    const previousTransform = context.getTransform();
    if (drawable) {
      context.setTransform(new DOMMatrix);
      context.drawImage(drawable, rectAfterTransforms.left - parentRect.x, rectAfterTransforms.top - parentRect.y, rectAfterTransforms.width, rectAfterTransforms.height);
      context.setTransform(previousTransform);
      Internals5.Log.trace({
        logLevel,
        tag: "@remotion/web-renderer"
      }, `Transforming element in 3D - canvas size: ${precomposeRect.width}x${precomposeRect.height} - compose: ${Date.now() - start}ms`);
      internalState.addPrecompose({
        canvasWidth: precomposeRect.width,
        canvasHeight: precomposeRect.height
      });
    }
    reset();
    cleanupWebGL();
    return { type: "skip-children" };
  }
  const { cleanupAfterChildren } = await drawElement({
    rect,
    computedStyle,
    context,
    draw,
    opacity,
    totalMatrix,
    parentRect,
    logLevel
  });
  reset();
  return { type: "continue", cleanupAfterChildren };
};

// src/drawing/text/draw-text.ts
import { Internals as Internals6 } from "remotion";

// src/drawing/text/apply-text-transform.ts
var applyTextTransform = (text, transform) => {
  if (transform === "uppercase") {
    return text.toUpperCase();
  }
  if (transform === "lowercase") {
    return text.toLowerCase();
  }
  if (transform === "capitalize") {
    return text.replace(/\b\w/g, (char) => char.toUpperCase());
  }
  return text;
};

// src/drawing/text/get-collapsed-text.ts
var getCollapsedText = (span) => {
  const textNode = span.firstChild;
  if (!textNode || textNode.nodeType !== Node.TEXT_NODE) {
    throw new Error("Span must contain a single text node");
  }
  const originalText = textNode.textContent || "";
  let collapsedText = originalText;
  const measureWidth = (text) => {
    textNode.textContent = text;
    return span.getBoundingClientRect().width;
  };
  const originalWidth = measureWidth(originalText);
  if (/^\s/.test(collapsedText)) {
    const trimmedLeading = collapsedText.replace(/^\s+/, "");
    const newWidth = measureWidth(trimmedLeading);
    if (newWidth === originalWidth) {
      collapsedText = trimmedLeading;
    }
  }
  if (/\s$/.test(collapsedText)) {
    const currentWidth = measureWidth(collapsedText);
    const trimmedTrailing = collapsedText.replace(/\s+$/, "");
    const newWidth = measureWidth(trimmedTrailing);
    if (newWidth === currentWidth) {
      collapsedText = trimmedTrailing;
    }
  }
  if (/\s\s/.test(collapsedText)) {
    const currentWidth = measureWidth(collapsedText);
    const collapsedInternal = collapsedText.replace(/\s\s+/g, " ");
    const newWidth = measureWidth(collapsedInternal);
    if (newWidth === currentWidth) {
      collapsedText = collapsedInternal;
    }
  }
  textNode.textContent = originalText;
  return collapsedText;
};

// src/drawing/text/find-line-breaks.text.ts
function findLineBreaks(span, rtl) {
  const textNode = span.childNodes[0];
  const originalText = textNode.textContent;
  const originalRect = span.getBoundingClientRect();
  const computedStyle = getComputedStyle(span);
  const segmenter = new Intl.Segmenter("en", { granularity: "word" });
  const segments = segmenter.segment(originalText);
  const words = Array.from(segments).map((s) => s.segment);
  const lines = [];
  let currentLine = "";
  let testText = "";
  let previousRect = originalRect;
  textNode.textContent = "";
  for (let i = 0;i < words.length; i += 1) {
    const word = words[i];
    testText += word;
    let wordsToAdd = word;
    while (typeof words[i + 1] !== "undefined" && words[i + 1].trim() === "") {
      testText += words[i + 1];
      wordsToAdd += words[i + 1];
      i++;
    }
    previousRect = span.getBoundingClientRect();
    textNode.textContent = testText;
    const collapsedText = getCollapsedText(span);
    textNode.textContent = collapsedText;
    const rect = span.getBoundingClientRect();
    const currentHeight = rect.height;
    if (previousRect && previousRect.height !== 0 && Math.abs(currentHeight - previousRect.height) > 2) {
      const offsetHorizontal = rtl ? previousRect.right - originalRect.right : previousRect.left - originalRect.left;
      const shouldCollapse = !computedStyle.whiteSpaceCollapse.includes("preserve");
      lines.push({
        text: shouldCollapse ? currentLine.trim() : currentLine,
        height: currentHeight - previousRect.height,
        offsetHorizontal
      });
      currentLine = wordsToAdd;
    } else {
      currentLine += wordsToAdd;
    }
  }
  if (currentLine) {
    textNode.textContent = testText;
    const rects = span.getClientRects();
    const rect = span.getBoundingClientRect();
    const lastRect = rects[rects.length - 1];
    const offsetHorizontal = rtl ? lastRect.right - originalRect.right : lastRect.left - originalRect.left;
    lines.push({
      text: currentLine,
      height: rect.height - lines.reduce((acc, curr) => acc + curr.height, 0),
      offsetHorizontal
    });
  }
  textNode.textContent = originalText;
  return lines;
}

// src/drawing/text/draw-text.ts
var drawText = ({
  span,
  logLevel
}) => {
  const drawFn = ({ dimensions: rect, computedStyle, contextToDraw }) => {
    const {
      fontFamily,
      fontSize,
      fontWeight,
      color,
      direction,
      writingMode,
      letterSpacing,
      textTransform
    } = computedStyle;
    const isVertical = writingMode !== "horizontal-tb";
    if (isVertical) {
      Internals6.Log.warn({
        logLevel,
        tag: "@remotion/web-renderer"
      }, 'Detected "writing-mode" CSS property. Vertical text is not yet supported in @remotion/web-renderer');
      return;
    }
    contextToDraw.save();
    const fontSizePx = parseFloat(fontSize);
    contextToDraw.font = `${fontWeight} ${fontSizePx}px ${fontFamily}`;
    contextToDraw.fillStyle = color;
    contextToDraw.letterSpacing = letterSpacing;
    const isRTL = direction === "rtl";
    contextToDraw.textAlign = isRTL ? "right" : "left";
    contextToDraw.textBaseline = "alphabetic";
    const originalText = span.textContent;
    const collapsedText = getCollapsedText(span);
    const transformedText = applyTextTransform(collapsedText, textTransform);
    span.textContent = transformedText;
    const xPosition = isRTL ? rect.right : rect.left;
    const lines = findLineBreaks(span, isRTL);
    let offsetTop = 0;
    const measurements = contextToDraw.measureText(lines[0].text);
    const { fontBoundingBoxDescent, fontBoundingBoxAscent } = measurements;
    const fontHeight = fontBoundingBoxAscent + fontBoundingBoxDescent;
    for (const line of lines) {
      const leading = line.height - fontHeight;
      const halfLeading = leading / 2;
      contextToDraw.fillText(line.text, xPosition + line.offsetHorizontal, rect.top + halfLeading + fontBoundingBoxAscent + offsetTop);
      offsetTop += line.height;
    }
    span.textContent = originalText;
    contextToDraw.restore();
  };
  return drawFn;
};

// src/drawing/text/handle-text-node.ts
var handleTextNode = async ({
  node,
  context,
  logLevel,
  parentRect,
  internalState,
  rootElement
}) => {
  const span = document.createElement("span");
  const parent = node.parentNode;
  if (!parent) {
    throw new Error("Text node has no parent");
  }
  parent.insertBefore(span, node);
  span.appendChild(node);
  const value = await processNode({
    context,
    element: span,
    draw: drawText({ span, logLevel }),
    logLevel,
    parentRect,
    internalState,
    rootElement
  });
  parent.insertBefore(node, span);
  parent.removeChild(span);
  return value;
};

// src/compose.ts
var walkOverNode = ({
  node,
  context,
  logLevel,
  parentRect,
  internalState,
  rootElement
}) => {
  if (node instanceof HTMLElement || node instanceof SVGElement) {
    return processNode({
      element: node,
      context,
      draw: drawDomElement(node),
      logLevel,
      parentRect,
      internalState,
      rootElement
    });
  }
  if (node instanceof Text) {
    return handleTextNode({
      node,
      context,
      logLevel,
      parentRect,
      internalState,
      rootElement
    });
  }
  throw new Error("Unknown node type");
};
var compose = async ({
  element,
  context,
  logLevel,
  parentRect,
  internalState
}) => {
  const cleanupAfterChildren = [];
  const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, (node) => {
    if (node instanceof Element) {
      if (node.parentElement instanceof SVGSVGElement) {
        return NodeFilter.FILTER_REJECT;
      }
      const computedStyle = getComputedStyle(node);
      return computedStyle.display === "none" ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
    }
    return NodeFilter.FILTER_ACCEPT;
  });
  while (true) {
    for (let i = 0;i < cleanupAfterChildren.length; ) {
      const cleanup = cleanupAfterChildren[i];
      if (!(cleanup.element === treeWalker.currentNode || cleanup.element.contains(treeWalker.currentNode))) {
        cleanup.cleanupFn();
        cleanupAfterChildren.splice(i, 1);
      } else {
        i++;
      }
    }
    const val = await walkOverNode({
      node: treeWalker.currentNode,
      context,
      logLevel,
      parentRect,
      internalState,
      rootElement: element
    });
    if (val.type === "skip-children") {
      if (!skipToNextNonDescendant(treeWalker)) {
        break;
      }
    } else {
      if (val.cleanupAfterChildren) {
        cleanupAfterChildren.unshift({
          element: treeWalker.currentNode,
          cleanupFn: val.cleanupAfterChildren
        });
      }
      if (!treeWalker.nextNode()) {
        break;
      }
    }
  }
  for (const cleanup of cleanupAfterChildren) {
    cleanup.cleanupFn();
  }
};

// src/take-screenshot.ts
var createFrame = async ({
  div,
  width,
  height,
  logLevel,
  internalState
}) => {
  const canvas = new OffscreenCanvas(width, height);
  const context = canvas.getContext("2d");
  if (!context) {
    throw new Error("Could not get context");
  }
  await compose({
    element: div,
    context,
    logLevel,
    parentRect: new DOMRect(0, 0, width, height),
    internalState
  });
  return canvas;
};
var takeScreenshot = async ({
  div,
  width,
  height,
  imageFormat,
  logLevel,
  internalState
}) => {
  const frame = await createFrame({
    div,
    width,
    height,
    logLevel,
    internalState
  });
  const imageData = await frame.convertToBlob({
    type: `image/${imageFormat}`
  });
  return imageData;
};

// src/throttle-progress.ts
var DEFAULT_THROTTLE_MS = 250;
var createThrottledProgressCallback = (callback, throttleMs = DEFAULT_THROTTLE_MS) => {
  if (!callback) {
    return null;
  }
  let lastCallTime = 0;
  let pendingUpdate = null;
  let timeoutId = null;
  const throttled = (progress) => {
    const now = Date.now();
    const timeSinceLastCall = now - lastCallTime;
    pendingUpdate = progress;
    if (timeSinceLastCall >= throttleMs) {
      lastCallTime = now;
      callback(progress);
      pendingUpdate = null;
      if (timeoutId !== null) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
    } else if (timeoutId === null) {
      const remainingTime = throttleMs - timeSinceLastCall;
      timeoutId = setTimeout(() => {
        if (pendingUpdate !== null) {
          lastCallTime = Date.now();
          callback(pendingUpdate);
          pendingUpdate = null;
        }
        timeoutId = null;
      }, remainingTime);
    }
  };
  return throttled;
};

// src/validate-video-frame.ts
var validateVideoFrame = ({
  originalFrame,
  returnedFrame,
  expectedWidth,
  expectedHeight,
  expectedTimestamp
}) => {
  if (!(returnedFrame instanceof VideoFrame)) {
    originalFrame.close();
    throw new Error("onFrame callback must return a VideoFrame or void");
  }
  if (returnedFrame === originalFrame) {
    return returnedFrame;
  }
  if (returnedFrame.displayWidth !== expectedWidth || returnedFrame.displayHeight !== expectedHeight) {
    originalFrame.close();
    returnedFrame.close();
    throw new Error(`VideoFrame dimensions mismatch: expected ${expectedWidth}x${expectedHeight}, got ${returnedFrame.displayWidth}x${returnedFrame.displayHeight}`);
  }
  if (returnedFrame.timestamp !== expectedTimestamp) {
    originalFrame.close();
    returnedFrame.close();
    throw new Error(`VideoFrame timestamp mismatch: expected ${expectedTimestamp}, got ${returnedFrame.timestamp}`);
  }
  originalFrame.close();
  return returnedFrame;
};

// src/wait-for-ready.ts
var waitForReady = ({
  timeoutInMilliseconds,
  scope,
  signal,
  apiName
}) => {
  const start = Date.now();
  const { promise, resolve, reject } = withResolvers();
  let cancelled = false;
  const check = () => {
    if (cancelled) {
      return;
    }
    if (signal?.aborted) {
      cancelled = true;
      reject(new Error(`${apiName}() was cancelled`));
      return;
    }
    if (scope.remotion_renderReady === true) {
      resolve();
      return;
    }
    if (scope.remotion_cancelledError !== undefined) {
      cancelled = true;
      reject(scope.remotion_cancelledError);
      return;
    }
    if (Date.now() - start > timeoutInMilliseconds + 3000) {
      cancelled = true;
      reject(new Error(Object.values(scope.remotion_delayRenderTimeouts).map((d) => d.label).join(", ")));
      return;
    }
    requestAnimationFrame(check);
  };
  requestAnimationFrame(check);
  return promise;
};

// src/web-fs-target.ts
var sessionId = null;
var getPrefix = () => {
  if (!sessionId) {
    sessionId = crypto.randomUUID();
  }
  return `__remotion_render:${sessionId}:`;
};
var cleanupStaleOpfsFiles = async () => {
  try {
    const root = await navigator.storage.getDirectory();
    for await (const [name] of root.entries()) {
      if (name.startsWith("__remotion_render:") && !name.startsWith(getPrefix())) {
        await root.removeEntry(name);
      }
    }
  } catch {}
};
var createWebFsTarget = async () => {
  const directoryHandle = await navigator.storage.getDirectory();
  const filename = `${getPrefix()}${crypto.randomUUID()}`;
  const fileHandle = await directoryHandle.getFileHandle(filename, {
    create: true
  });
  const writable = await fileHandle.createWritable();
  const stream = new WritableStream({
    async write(chunk) {
      await writable.seek(chunk.position);
      await writable.write(chunk);
    }
  });
  const getBlob = async () => {
    const handle = await directoryHandle.getFileHandle(filename);
    return handle.getFile();
  };
  const close = () => writable.close();
  return { stream, getBlob, close };
};

// src/render-media-on-web.tsx
var internalRenderMediaOnWeb = async ({
  composition,
  inputProps,
  delayRenderTimeoutInMilliseconds,
  logLevel,
  mediaCacheSizeInBytes,
  schema,
  videoCodec: codec,
  container,
  signal,
  onProgress,
  hardwareAcceleration,
  keyframeIntervalInSeconds,
  videoBitrate,
  frameRange,
  transparent,
  onArtifact,
  onFrame,
  outputTarget: userDesiredOutputTarget,
  licenseKey,
  muted
}) => {
  const outputTarget = userDesiredOutputTarget === null ? await canUseWebFsWriter() ? "web-fs" : "arraybuffer" : userDesiredOutputTarget;
  if (outputTarget === "web-fs") {
    await cleanupStaleOpfsFiles();
  }
  const cleanupFns = [];
  const format = containerToMediabunnyContainer(container);
  if (codec && !format.getSupportedCodecs().includes(codecToMediabunnyCodec(codec))) {
    return Promise.reject(new Error(`Codec ${codec} is not supported for container ${container}`));
  }
  const resolved = await Internals7.resolveVideoConfig({
    calculateMetadata: composition.calculateMetadata ?? null,
    signal: signal ?? new AbortController().signal,
    defaultProps: composition.defaultProps ?? {},
    inputProps: inputProps ?? {},
    compositionId: composition.id,
    compositionDurationInFrames: composition.durationInFrames ?? null,
    compositionFps: composition.fps ?? null,
    compositionHeight: composition.height ?? null,
    compositionWidth: composition.width ?? null
  });
  const realFrameRange = getRealFrameRange(resolved.durationInFrames, frameRange);
  if (signal?.aborted) {
    return Promise.reject(new Error("renderMediaOnWeb() was cancelled"));
  }
  const { delayRenderScope, div, cleanupScaffold, timeUpdater, collectAssets } = await createScaffold({
    width: resolved.width,
    height: resolved.height,
    fps: resolved.fps,
    durationInFrames: resolved.durationInFrames,
    Component: composition.component,
    resolvedProps: resolved.props,
    id: resolved.id,
    delayRenderTimeoutInMilliseconds,
    logLevel,
    mediaCacheSizeInBytes,
    schema: schema ?? null,
    audioEnabled: !muted,
    videoEnabled: true,
    initialFrame: 0,
    defaultCodec: resolved.defaultCodec,
    defaultOutName: resolved.defaultOutName
  });
  const internalState = makeInternalState();
  const artifactsHandler = handleArtifacts();
  cleanupFns.push(() => {
    cleanupScaffold();
  });
  const webFsTarget = outputTarget === "web-fs" ? await createWebFsTarget() : null;
  const target = webFsTarget ? new StreamTarget(webFsTarget.stream) : new BufferTarget;
  const output = new Output({
    format,
    target
  });
  try {
    if (signal?.aborted) {
      throw new Error("renderMediaOnWeb() was cancelled");
    }
    await waitForReady({
      timeoutInMilliseconds: delayRenderTimeoutInMilliseconds,
      scope: delayRenderScope,
      signal,
      apiName: "renderMediaOnWeb"
    });
    if (signal?.aborted) {
      throw new Error("renderMediaOnWeb() was cancelled");
    }
    cleanupFns.push(() => {
      if (output.state === "finalized" || output.state === "canceled") {
        return;
      }
      output.cancel();
    });
    const videoSampleSource = new VideoSampleSource({
      codec: codecToMediabunnyCodec(codec),
      bitrate: typeof videoBitrate === "number" ? videoBitrate : getQualityForWebRendererQuality(videoBitrate),
      sizeChangeBehavior: "deny",
      hardwareAcceleration,
      latencyMode: "quality",
      keyFrameInterval: keyframeIntervalInSeconds,
      alpha: transparent ? "keep" : "discard"
    });
    cleanupFns.push(() => {
      videoSampleSource.close();
    });
    output.addVideoTrack(videoSampleSource);
    let audioSampleSource = null;
    if (!muted) {
      const defaultAudioEncodingConfig = await getDefaultAudioEncodingConfig();
      if (!defaultAudioEncodingConfig) {
        return Promise.reject(new Error("No default audio encoding config found"));
      }
      audioSampleSource = new AudioSampleSource(defaultAudioEncodingConfig);
      cleanupFns.push(() => {
        audioSampleSource?.close();
      });
      output.addAudioTrack(audioSampleSource);
    }
    await output.start();
    if (signal?.aborted) {
      throw new Error("renderMediaOnWeb() was cancelled");
    }
    const progress = {
      renderedFrames: 0,
      encodedFrames: 0
    };
    const throttledOnProgress = createThrottledProgressCallback(onProgress);
    for (let frame = realFrameRange[0];frame <= realFrameRange[1]; frame++) {
      if (signal?.aborted) {
        throw new Error("renderMediaOnWeb() was cancelled");
      }
      timeUpdater.current?.update(frame);
      await waitForReady({
        timeoutInMilliseconds: delayRenderTimeoutInMilliseconds,
        scope: delayRenderScope,
        signal,
        apiName: "renderMediaOnWeb"
      });
      if (signal?.aborted) {
        throw new Error("renderMediaOnWeb() was cancelled");
      }
      const imageData = await createFrame({
        div,
        width: resolved.width,
        height: resolved.height,
        logLevel,
        internalState
      });
      if (signal?.aborted) {
        throw new Error("renderMediaOnWeb() was cancelled");
      }
      const assets = collectAssets.current.collectAssets();
      if (onArtifact) {
        await artifactsHandler.handle({
          imageData,
          frame,
          assets,
          onArtifact
        });
      }
      if (signal?.aborted) {
        throw new Error("renderMediaOnWeb() was cancelled");
      }
      const audio = muted ? null : onlyInlineAudio({ assets, fps: resolved.fps, frame });
      const timestamp = Math.round((frame - realFrameRange[0]) / resolved.fps * 1e6);
      const videoFrame = new VideoFrame(imageData, {
        timestamp
      });
      progress.renderedFrames++;
      throttledOnProgress?.({ ...progress });
      let frameToEncode = videoFrame;
      if (onFrame) {
        const returnedFrame = await onFrame(videoFrame);
        if (signal?.aborted) {
          throw new Error("renderMediaOnWeb() was cancelled");
        }
        frameToEncode = validateVideoFrame({
          originalFrame: videoFrame,
          returnedFrame,
          expectedWidth: resolved.width,
          expectedHeight: resolved.height,
          expectedTimestamp: timestamp
        });
      }
      await Promise.all([
        addVideoSampleAndCloseFrame(frameToEncode, videoSampleSource),
        audio && audioSampleSource ? addAudioSample(audio, audioSampleSource) : Promise.resolve()
      ]);
      progress.encodedFrames++;
      throttledOnProgress?.({ ...progress });
      if (signal?.aborted) {
        throw new Error("renderMediaOnWeb() was cancelled");
      }
    }
    onProgress?.({ ...progress });
    videoSampleSource.close();
    audioSampleSource?.close();
    await output.finalize();
    const mimeType = getMimeType(container);
    if (webFsTarget) {
      sendUsageEvent({
        licenseKey: licenseKey ?? null,
        succeeded: true,
        apiName: "renderMediaOnWeb"
      });
      await webFsTarget.close();
      return {
        getBlob: () => {
          return webFsTarget.getBlob();
        },
        internalState
      };
    }
    if (!(target instanceof BufferTarget)) {
      throw new Error("Expected target to be a BufferTarget");
    }
    sendUsageEvent({
      licenseKey: licenseKey ?? null,
      succeeded: true,
      apiName: "renderMediaOnWeb"
    });
    return {
      getBlob: () => {
        if (!target.buffer) {
          throw new Error("The resulting buffer is empty");
        }
        return Promise.resolve(new Blob([target.buffer], { type: mimeType }));
      },
      internalState
    };
  } catch (err) {
    sendUsageEvent({
      succeeded: false,
      licenseKey: licenseKey ?? null,
      apiName: "renderMediaOnWeb"
    }).catch((err2) => {
      Internals7.Log.error({ logLevel: "error", tag: "web-renderer" }, "Failed to send usage event", err2);
    });
    throw err;
  } finally {
    cleanupFns.forEach((fn) => fn());
  }
};
var renderMediaOnWeb = (options) => {
  const container = options.container ?? "mp4";
  const codec = options.videoCodec ?? getDefaultVideoCodecForContainer(container);
  onlyOneRenderAtATimeQueue.ref = onlyOneRenderAtATimeQueue.ref.catch(() => Promise.resolve()).then(() => internalRenderMediaOnWeb({
    ...options,
    delayRenderTimeoutInMilliseconds: options.delayRenderTimeoutInMilliseconds ?? 30000,
    logLevel: options.logLevel ?? window.remotion_logLevel ?? "info",
    schema: options.schema ?? undefined,
    mediaCacheSizeInBytes: options.mediaCacheSizeInBytes ?? null,
    videoCodec: codec,
    container,
    signal: options.signal ?? null,
    onProgress: options.onProgress ?? null,
    hardwareAcceleration: options.hardwareAcceleration ?? "no-preference",
    keyframeIntervalInSeconds: options.keyframeIntervalInSeconds ?? 5,
    videoBitrate: options.videoBitrate ?? "medium",
    frameRange: options.frameRange ?? null,
    transparent: options.transparent ?? false,
    onArtifact: options.onArtifact ?? null,
    onFrame: options.onFrame ?? null,
    outputTarget: options.outputTarget ?? null,
    licenseKey: options.licenseKey ?? undefined,
    muted: options.muted ?? false
  }));
  return onlyOneRenderAtATimeQueue.ref;
};
// src/render-still-on-web.tsx
import {
  Internals as Internals8
} from "remotion";
async function internalRenderStillOnWeb({
  frame,
  delayRenderTimeoutInMilliseconds,
  logLevel,
  inputProps,
  schema,
  imageFormat,
  mediaCacheSizeInBytes,
  composition,
  signal,
  onArtifact,
  licenseKey
}) {
  const resolved = await Internals8.resolveVideoConfig({
    calculateMetadata: composition.calculateMetadata ?? null,
    signal: signal ?? new AbortController().signal,
    defaultProps: composition.defaultProps ?? {},
    inputProps: inputProps ?? {},
    compositionId: composition.id,
    compositionDurationInFrames: composition.durationInFrames ?? null,
    compositionFps: composition.fps ?? null,
    compositionHeight: composition.height ?? null,
    compositionWidth: composition.width ?? null
  });
  if (signal?.aborted) {
    return Promise.reject(new Error("renderStillOnWeb() was cancelled"));
  }
  const internalState = makeInternalState();
  const { delayRenderScope, div, cleanupScaffold, collectAssets } = await createScaffold({
    width: resolved.width,
    height: resolved.height,
    delayRenderTimeoutInMilliseconds,
    logLevel,
    resolvedProps: resolved.props,
    id: resolved.id,
    mediaCacheSizeInBytes,
    audioEnabled: false,
    Component: composition.component,
    videoEnabled: true,
    durationInFrames: resolved.durationInFrames,
    fps: resolved.fps,
    schema: schema ?? null,
    initialFrame: frame,
    defaultCodec: resolved.defaultCodec,
    defaultOutName: resolved.defaultOutName
  });
  const artifactsHandler = handleArtifacts();
  try {
    if (signal?.aborted) {
      throw new Error("renderStillOnWeb() was cancelled");
    }
    await waitForReady({
      timeoutInMilliseconds: delayRenderTimeoutInMilliseconds,
      scope: delayRenderScope,
      signal,
      apiName: "renderStillOnWeb"
    });
    if (signal?.aborted) {
      throw new Error("renderStillOnWeb() was cancelled");
    }
    const imageData = await takeScreenshot({
      div,
      width: resolved.width,
      height: resolved.height,
      imageFormat,
      logLevel,
      internalState
    });
    const assets = collectAssets.current.collectAssets();
    if (onArtifact) {
      await artifactsHandler.handle({ imageData, frame, assets, onArtifact });
    }
    sendUsageEvent({
      licenseKey: licenseKey ?? null,
      succeeded: true,
      apiName: "renderStillOnWeb"
    });
    return { blob: imageData, internalState };
  } catch (err) {
    sendUsageEvent({
      succeeded: false,
      licenseKey: licenseKey ?? null,
      apiName: "renderStillOnWeb"
    }).catch((err2) => {
      Internals8.Log.error({ logLevel: "error", tag: "web-renderer" }, "Failed to send usage event", err2);
    });
    throw err;
  } finally {
    cleanupScaffold();
  }
}
var renderStillOnWeb = (options) => {
  onlyOneRenderAtATimeQueue.ref = onlyOneRenderAtATimeQueue.ref.catch(() => Promise.resolve()).then(() => internalRenderStillOnWeb({
    ...options,
    delayRenderTimeoutInMilliseconds: options.delayRenderTimeoutInMilliseconds ?? 30000,
    logLevel: options.logLevel ?? window.remotion_logLevel ?? "info",
    schema: options.schema ?? undefined,
    mediaCacheSizeInBytes: options.mediaCacheSizeInBytes ?? null,
    signal: options.signal ?? null,
    onArtifact: options.onArtifact ?? null,
    licenseKey: options.licenseKey ?? undefined
  }));
  return onlyOneRenderAtATimeQueue.ref;
};
export {
  renderStillOnWeb,
  renderMediaOnWeb
};
