import { drawDomElement } from './drawing/draw-dom-element';
import { processNode } from './drawing/process-node';
import { handleTextNode } from './drawing/text/handle-text-node';
import { skipToNextNonDescendant } from './walk-tree';
const walkOverNode = ({ node, context, logLevel, parentRect, internalState, rootElement, }) => {
    if (node instanceof HTMLElement || node instanceof SVGElement) {
        return processNode({
            element: node,
            context,
            draw: drawDomElement(node),
            logLevel,
            parentRect,
            internalState,
            rootElement,
        });
    }
    if (node instanceof Text) {
        return handleTextNode({
            node,
            context,
            logLevel,
            parentRect,
            internalState,
            rootElement,
        });
    }
    throw new Error('Unknown node type');
};
export const compose = async ({ element, context, logLevel, parentRect, internalState, }) => {
    const cleanupAfterChildren = [];
    const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, (node) => {
        if (node instanceof Element) {
            // SVG does have children, but we process SVG elements in its
            // entirety
            if (node.parentElement instanceof SVGSVGElement) {
                return NodeFilter.FILTER_REJECT;
            }
            const computedStyle = getComputedStyle(node);
            return computedStyle.display === 'none'
                ? NodeFilter.FILTER_REJECT
                : NodeFilter.FILTER_ACCEPT;
        }
        return NodeFilter.FILTER_ACCEPT;
    });
    while (true) {
        for (let i = 0; i < cleanupAfterChildren.length;) {
            const cleanup = cleanupAfterChildren[i];
            if (!(cleanup.element === treeWalker.currentNode ||
                cleanup.element.contains(treeWalker.currentNode))) {
                cleanup.cleanupFn();
                cleanupAfterChildren.splice(i, 1);
            }
            else {
                i++;
            }
        }
        const val = await walkOverNode({
            node: treeWalker.currentNode,
            context,
            logLevel,
            parentRect,
            internalState,
            rootElement: element,
        });
        if (val.type === 'skip-children') {
            if (!skipToNextNonDescendant(treeWalker)) {
                break;
            }
        }
        else {
            if (val.cleanupAfterChildren) {
                // Last registered must be cleaned up first
                cleanupAfterChildren.unshift({
                    element: treeWalker.currentNode,
                    cleanupFn: val.cleanupAfterChildren,
                });
            }
            if (!treeWalker.nextNode()) {
                break;
            }
        }
    }
    for (const cleanup of cleanupAfterChildren) {
        cleanup.cleanupFn();
    }
};
